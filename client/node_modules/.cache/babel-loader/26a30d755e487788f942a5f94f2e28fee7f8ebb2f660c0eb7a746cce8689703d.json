{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCdpHandle = exports.ExecutionContext = void 0;\nconst LazyArg_js_1 = require(\"../common/LazyArg.js\");\nconst ScriptInjector_js_1 = require(\"../common/ScriptInjector.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst AsyncIterableUtil_js_1 = require(\"../util/AsyncIterableUtil.js\");\nconst Function_js_1 = require(\"../util/Function.js\");\nconst AriaQueryHandler_js_1 = require(\"./AriaQueryHandler.js\");\nconst Binding_js_1 = require(\"./Binding.js\");\nconst ElementHandle_js_1 = require(\"./ElementHandle.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/**\n * @internal\n */\nclass ExecutionContext {\n  _client;\n  _world;\n  _contextId;\n  _contextName;\n  constructor(client, contextPayload, world) {\n    this._client = client;\n    this._world = world;\n    this._contextId = contextPayload.id;\n    if (contextPayload.name) {\n      this._contextName = contextPayload.name;\n    }\n  }\n  #bindingsInstalled = false;\n  #puppeteerUtil;\n  get puppeteerUtil() {\n    let promise = Promise.resolve();\n    if (!this.#bindingsInstalled) {\n      promise = Promise.all([this.#installGlobalBinding(new Binding_js_1.Binding('__ariaQuerySelector', AriaQueryHandler_js_1.ARIAQueryHandler.queryOne)), this.#installGlobalBinding(new Binding_js_1.Binding('__ariaQuerySelectorAll', async (element, selector) => {\n        const results = AriaQueryHandler_js_1.ARIAQueryHandler.queryAll(element, selector);\n        return await element.realm.evaluateHandle((...elements) => {\n          return elements;\n        }, ...(await AsyncIterableUtil_js_1.AsyncIterableUtil.collect(results)));\n      }))]);\n      this.#bindingsInstalled = true;\n    }\n    ScriptInjector_js_1.scriptInjector.inject(script => {\n      if (this.#puppeteerUtil) {\n        void this.#puppeteerUtil.then(handle => {\n          void handle.dispose();\n        });\n      }\n      this.#puppeteerUtil = promise.then(() => {\n        return this.evaluateHandle(script);\n      });\n    }, !this.#puppeteerUtil);\n    return this.#puppeteerUtil;\n  }\n  async #installGlobalBinding(binding) {\n    try {\n      if (this._world) {\n        this._world._bindings.set(binding.name, binding);\n        await this._world._addBindingToContext(this, binding.name);\n      }\n    } catch {\n      // If the binding cannot be added, then either the browser doesn't support\n      // bindings (e.g. Firefox) or the context is broken. Either breakage is\n      // okay, so we ignore the error.\n    }\n  }\n  /**\n   * Evaluates the given function.\n   *\n   * @example\n   *\n   * ```ts\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function:\n   *\n   * ```ts\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *   (a, b) => a + b,\n   *   oneHandle,\n   *   twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns The result of evaluating the function. If the result is an object,\n   * a vanilla object containing the serializable properties of the result is\n   * returned.\n   */\n  async evaluate(pageFunction, ...args) {\n    return await this.#evaluate(true, pageFunction, ...args);\n  }\n  /**\n   * Evaluates the given function.\n   *\n   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a\n   * handle to the result of the function.\n   *\n   * This method may be better suited if the object cannot be serialized (e.g.\n   * `Map`) and requires further manipulation.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = await page.mainFrame().executionContext();\n   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(\n   *   () => Promise.resolve(self)\n   * );\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```ts\n   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const bodyHandle: ElementHandle<HTMLBodyElement> =\n   *   await context.evaluateHandle(() => {\n   *     return document.body;\n   *   });\n   * const stringHandle: JSHandle<string> = await context.evaluateHandle(\n   *   body => body.innerHTML,\n   *   body\n   * );\n   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML\n   * // Always dispose your garbage! :)\n   * await bodyHandle.dispose();\n   * await stringHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns A {@link JSHandle | handle} to the result of evaluating the\n   * function. If the result is a `Node`, then this will return an\n   * {@link ElementHandle | element handle}.\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    return await this.#evaluate(false, pageFunction, ...args);\n  }\n  async #evaluate(returnByValue, pageFunction, ...args) {\n    const sourceUrlComment = (0, util_js_1.getSourceUrlComment)((0, util_js_1.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ?? util_js_1.PuppeteerURL.INTERNAL_URL);\n    if ((0, util_js_1.isString)(pageFunction)) {\n      const contextId = this._contextId;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = util_js_1.SOURCE_URL_REGEX.test(expression) ? expression : `${expression}\\n${sourceUrlComment}\\n`;\n      const {\n        exceptionDetails,\n        result: remoteObject\n      } = await this._client.send('Runtime.evaluate', {\n        expression: expressionWithSourceUrl,\n        contextId,\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      }).catch(rewriteError);\n      if (exceptionDetails) {\n        throw (0, utils_js_1.createEvaluationError)(exceptionDetails);\n      }\n      return returnByValue ? (0, utils_js_1.valueFromRemoteObject)(remoteObject) : createCdpHandle(this._world, remoteObject);\n    }\n    const functionDeclaration = (0, Function_js_1.stringifyFunction)(pageFunction);\n    const functionDeclarationWithSourceUrl = util_js_1.SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}\\n${sourceUrlComment}\\n`;\n    let callFunctionOnPromise;\n    try {\n      callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionDeclarationWithSourceUrl,\n        executionContextId: this._contextId,\n        arguments: args.length ? await Promise.all(args.map(convertArgument.bind(this))) : [],\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      });\n    } catch (error) {\n      if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) {\n        error.message += ' Recursive objects are not allowed.';\n      }\n      throw error;\n    }\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) {\n      throw (0, utils_js_1.createEvaluationError)(exceptionDetails);\n    }\n    return returnByValue ? (0, utils_js_1.valueFromRemoteObject)(remoteObject) : createCdpHandle(this._world, remoteObject);\n    async function convertArgument(arg) {\n      if (arg instanceof LazyArg_js_1.LazyArg) {\n        arg = await arg.get(this);\n      }\n      if (typeof arg === 'bigint') {\n        // eslint-disable-line valid-typeof\n        return {\n          unserializableValue: `${arg.toString()}n`\n        };\n      }\n      if (Object.is(arg, -0)) {\n        return {\n          unserializableValue: '-0'\n        };\n      }\n      if (Object.is(arg, Infinity)) {\n        return {\n          unserializableValue: 'Infinity'\n        };\n      }\n      if (Object.is(arg, -Infinity)) {\n        return {\n          unserializableValue: '-Infinity'\n        };\n      }\n      if (Object.is(arg, NaN)) {\n        return {\n          unserializableValue: 'NaN'\n        };\n      }\n      const objectHandle = arg && (arg instanceof JSHandle_js_1.CdpJSHandle || arg instanceof ElementHandle_js_1.CdpElementHandle) ? arg : null;\n      if (objectHandle) {\n        if (objectHandle.realm !== this._world) {\n          throw new Error('JSHandles can be evaluated only in the context they were created!');\n        }\n        if (objectHandle.disposed) {\n          throw new Error('JSHandle is disposed!');\n        }\n        if (objectHandle.remoteObject().unserializableValue) {\n          return {\n            unserializableValue: objectHandle.remoteObject().unserializableValue\n          };\n        }\n        if (!objectHandle.remoteObject().objectId) {\n          return {\n            value: objectHandle.remoteObject().value\n          };\n        }\n        return {\n          objectId: objectHandle.remoteObject().objectId\n        };\n      }\n      return {\n        value: arg\n      };\n    }\n  }\n}\nexports.ExecutionContext = ExecutionContext;\nconst rewriteError = error => {\n  if (error.message.includes('Object reference chain is too long')) {\n    return {\n      result: {\n        type: 'undefined'\n      }\n    };\n  }\n  if (error.message.includes(\"Object couldn't be returned by value\")) {\n    return {\n      result: {\n        type: 'undefined'\n      }\n    };\n  }\n  if (error.message.endsWith('Cannot find context with specified id') || error.message.endsWith('Inspected target navigated or closed')) {\n    throw new Error('Execution context was destroyed, most likely because of a navigation.');\n  }\n  throw error;\n};\n/**\n * @internal\n */\nfunction createCdpHandle(realm, remoteObject) {\n  if (remoteObject.subtype === 'node') {\n    return new ElementHandle_js_1.CdpElementHandle(realm, remoteObject);\n  }\n  return new JSHandle_js_1.CdpJSHandle(realm, remoteObject);\n}\nexports.createCdpHandle = createCdpHandle;","map":{"version":3,"names":["LazyArg_js_1","require","ScriptInjector_js_1","util_js_1","AsyncIterableUtil_js_1","Function_js_1","AriaQueryHandler_js_1","Binding_js_1","ElementHandle_js_1","JSHandle_js_1","utils_js_1","ExecutionContext","_client","_world","_contextId","_contextName","constructor","client","contextPayload","world","id","name","bindingsInstalled","puppeteerUtil","promise","Promise","resolve","all","installGlobalBinding","Binding","ARIAQueryHandler","queryOne","element","selector","results","queryAll","realm","evaluateHandle","elements","AsyncIterableUtil","collect","scriptInjector","inject","script","then","handle","dispose","#installGlobalBinding","binding","_bindings","set","_addBindingToContext","evaluate","pageFunction","args","#evaluate","returnByValue","sourceUrlComment","getSourceUrlComment","getSourcePuppeteerURLIfAvailable","toString","PuppeteerURL","INTERNAL_URL","isString","contextId","expression","expressionWithSourceUrl","SOURCE_URL_REGEX","test","exceptionDetails","result","remoteObject","send","awaitPromise","userGesture","catch","rewriteError","createEvaluationError","valueFromRemoteObject","createCdpHandle","functionDeclaration","stringifyFunction","functionDeclarationWithSourceUrl","callFunctionOnPromise","executionContextId","arguments","length","map","convertArgument","bind","error","TypeError","message","startsWith","arg","LazyArg","get","unserializableValue","Object","is","Infinity","NaN","objectHandle","CdpJSHandle","CdpElementHandle","Error","disposed","objectId","value","exports","includes","type","endsWith","subtype"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/node_modules/puppeteer-core/src/cdp/ExecutionContext.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport {scriptInjector} from '../common/ScriptInjector.js';\nimport type {EvaluateFunc, HandleFor} from '../common/types.js';\nimport {\n  PuppeteerURL,\n  SOURCE_URL_REGEX,\n  getSourcePuppeteerURLIfAvailable,\n  getSourceUrlComment,\n  isString,\n} from '../common/util.js';\nimport type PuppeteerUtil from '../injected/injected.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {stringifyFunction} from '../util/Function.js';\n\nimport {ARIAQueryHandler} from './AriaQueryHandler.js';\nimport {Binding} from './Binding.js';\nimport {CdpElementHandle} from './ElementHandle.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {CdpJSHandle} from './JSHandle.js';\nimport {createEvaluationError, valueFromRemoteObject} from './utils.js';\n\n/**\n * @internal\n */\nexport class ExecutionContext {\n  _client: CDPSession;\n  _world: IsolatedWorld;\n  _contextId: number;\n  _contextName?: string;\n\n  constructor(\n    client: CDPSession,\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    world: IsolatedWorld\n  ) {\n    this._client = client;\n    this._world = world;\n    this._contextId = contextPayload.id;\n    if (contextPayload.name) {\n      this._contextName = contextPayload.name;\n    }\n  }\n\n  #bindingsInstalled = false;\n  #puppeteerUtil?: Promise<JSHandle<PuppeteerUtil>>;\n  get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>> {\n    let promise = Promise.resolve() as Promise<unknown>;\n    if (!this.#bindingsInstalled) {\n      promise = Promise.all([\n        this.#installGlobalBinding(\n          new Binding(\n            '__ariaQuerySelector',\n            ARIAQueryHandler.queryOne as (...args: unknown[]) => unknown\n          )\n        ),\n        this.#installGlobalBinding(\n          new Binding('__ariaQuerySelectorAll', (async (\n            element: ElementHandle<Node>,\n            selector: string\n          ): Promise<JSHandle<Node[]>> => {\n            const results = ARIAQueryHandler.queryAll(element, selector);\n            return await element.realm.evaluateHandle(\n              (...elements) => {\n                return elements;\n              },\n              ...(await AsyncIterableUtil.collect(results))\n            );\n          }) as (...args: unknown[]) => unknown)\n        ),\n      ]);\n      this.#bindingsInstalled = true;\n    }\n    scriptInjector.inject(script => {\n      if (this.#puppeteerUtil) {\n        void this.#puppeteerUtil.then(handle => {\n          void handle.dispose();\n        });\n      }\n      this.#puppeteerUtil = promise.then(() => {\n        return this.evaluateHandle(script) as Promise<JSHandle<PuppeteerUtil>>;\n      });\n    }, !this.#puppeteerUtil);\n    return this.#puppeteerUtil as Promise<JSHandle<PuppeteerUtil>>;\n  }\n\n  async #installGlobalBinding(binding: Binding) {\n    try {\n      if (this._world) {\n        this._world._bindings.set(binding.name, binding);\n        await this._world._addBindingToContext(this, binding.name);\n      }\n    } catch {\n      // If the binding cannot be added, then either the browser doesn't support\n      // bindings (e.g. Firefox) or the context is broken. Either breakage is\n      // okay, so we ignore the error.\n    }\n  }\n\n  /**\n   * Evaluates the given function.\n   *\n   * @example\n   *\n   * ```ts\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function:\n   *\n   * ```ts\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *   (a, b) => a + b,\n   *   oneHandle,\n   *   twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns The result of evaluating the function. If the result is an object,\n   * a vanilla object containing the serializable properties of the result is\n   * returned.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    return await this.#evaluate(true, pageFunction, ...args);\n  }\n\n  /**\n   * Evaluates the given function.\n   *\n   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a\n   * handle to the result of the function.\n   *\n   * This method may be better suited if the object cannot be serialized (e.g.\n   * `Map`) and requires further manipulation.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = await page.mainFrame().executionContext();\n   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(\n   *   () => Promise.resolve(self)\n   * );\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```ts\n   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const bodyHandle: ElementHandle<HTMLBodyElement> =\n   *   await context.evaluateHandle(() => {\n   *     return document.body;\n   *   });\n   * const stringHandle: JSHandle<string> = await context.evaluateHandle(\n   *   body => body.innerHTML,\n   *   body\n   * );\n   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML\n   * // Always dispose your garbage! :)\n   * await bodyHandle.dispose();\n   * await stringHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns A {@link JSHandle | handle} to the result of evaluating the\n   * function. If the result is a `Node`, then this will return an\n   * {@link ElementHandle | element handle}.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return await this.#evaluate(false, pageFunction, ...args);\n  }\n\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: true,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: false,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: boolean,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>> | Awaited<ReturnType<Func>>> {\n    const sourceUrlComment = getSourceUrlComment(\n      getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??\n        PuppeteerURL.INTERNAL_URL\n    );\n\n    if (isString(pageFunction)) {\n      const contextId = this._contextId;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)\n        ? expression\n        : `${expression}\\n${sourceUrlComment}\\n`;\n\n      const {exceptionDetails, result: remoteObject} = await this._client\n        .send('Runtime.evaluate', {\n          expression: expressionWithSourceUrl,\n          contextId,\n          returnByValue,\n          awaitPromise: true,\n          userGesture: true,\n        })\n        .catch(rewriteError);\n\n      if (exceptionDetails) {\n        throw createEvaluationError(exceptionDetails);\n      }\n\n      return returnByValue\n        ? valueFromRemoteObject(remoteObject)\n        : createCdpHandle(this._world, remoteObject);\n    }\n\n    const functionDeclaration = stringifyFunction(pageFunction);\n    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(\n      functionDeclaration\n    )\n      ? functionDeclaration\n      : `${functionDeclaration}\\n${sourceUrlComment}\\n`;\n    let callFunctionOnPromise;\n    try {\n      callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionDeclarationWithSourceUrl,\n        executionContextId: this._contextId,\n        arguments: args.length\n          ? await Promise.all(args.map(convertArgument.bind(this)))\n          : [],\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true,\n      });\n    } catch (error) {\n      if (\n        error instanceof TypeError &&\n        error.message.startsWith('Converting circular structure to JSON')\n      ) {\n        error.message += ' Recursive objects are not allowed.';\n      }\n      throw error;\n    }\n    const {exceptionDetails, result: remoteObject} =\n      await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) {\n      throw createEvaluationError(exceptionDetails);\n    }\n    return returnByValue\n      ? valueFromRemoteObject(remoteObject)\n      : createCdpHandle(this._world, remoteObject);\n\n    async function convertArgument(\n      this: ExecutionContext,\n      arg: unknown\n    ): Promise<Protocol.Runtime.CallArgument> {\n      if (arg instanceof LazyArg) {\n        arg = await arg.get(this);\n      }\n      if (typeof arg === 'bigint') {\n        // eslint-disable-line valid-typeof\n        return {unserializableValue: `${arg.toString()}n`};\n      }\n      if (Object.is(arg, -0)) {\n        return {unserializableValue: '-0'};\n      }\n      if (Object.is(arg, Infinity)) {\n        return {unserializableValue: 'Infinity'};\n      }\n      if (Object.is(arg, -Infinity)) {\n        return {unserializableValue: '-Infinity'};\n      }\n      if (Object.is(arg, NaN)) {\n        return {unserializableValue: 'NaN'};\n      }\n      const objectHandle =\n        arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle)\n          ? arg\n          : null;\n      if (objectHandle) {\n        if (objectHandle.realm !== this._world) {\n          throw new Error(\n            'JSHandles can be evaluated only in the context they were created!'\n          );\n        }\n        if (objectHandle.disposed) {\n          throw new Error('JSHandle is disposed!');\n        }\n        if (objectHandle.remoteObject().unserializableValue) {\n          return {\n            unserializableValue:\n              objectHandle.remoteObject().unserializableValue,\n          };\n        }\n        if (!objectHandle.remoteObject().objectId) {\n          return {value: objectHandle.remoteObject().value};\n        }\n        return {objectId: objectHandle.remoteObject().objectId};\n      }\n      return {value: arg};\n    }\n  }\n}\n\nconst rewriteError = (error: Error): Protocol.Runtime.EvaluateResponse => {\n  if (error.message.includes('Object reference chain is too long')) {\n    return {result: {type: 'undefined'}};\n  }\n  if (error.message.includes(\"Object couldn't be returned by value\")) {\n    return {result: {type: 'undefined'}};\n  }\n\n  if (\n    error.message.endsWith('Cannot find context with specified id') ||\n    error.message.endsWith('Inspected target navigated or closed')\n  ) {\n    throw new Error(\n      'Execution context was destroyed, most likely because of a navigation.'\n    );\n  }\n  throw error;\n};\n\n/**\n * @internal\n */\nexport function createCdpHandle(\n  realm: IsolatedWorld,\n  remoteObject: Protocol.Runtime.RemoteObject\n): JSHandle | ElementHandle<Node> {\n  if (remoteObject.subtype === 'node') {\n    return new CdpElementHandle(realm, remoteObject);\n  }\n  return new CdpJSHandle(realm, remoteObject);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}