{"ast":null,"code":"import _defineProperty from \"/Users/carlosgutierrez/Documents/React/spanish/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign({}, ...props.map(prop => {\n    if (o[prop] !== void 0) {\n      return {\n        [prop]: o[prop]\n      };\n    }\n  }));\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter(prop => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = \"\".concat(model, \":\").concat(accessToken);\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    var _options$fetch;\n    const modelTask = await ((_options$fetch = options === null || options === void 0 ? void 0 : options.fetch) !== null && _options$fetch !== void 0 ? _options$fetch : fetch)(\"\".concat(HF_HUB_URL, \"/api/models/\").concat(model, \"?expand[]=pipeline_tag\"), {\n      headers: accessToken ? {\n        Authorization: \"Bearer \".concat(accessToken)\n      } : {}\n    }).then(resp => resp.json()).then(json => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = {\n      task: modelTask,\n      date: /* @__PURE__ */new Date()\n    };\n    taskCache.set(key, {\n      task: modelTask,\n      date: /* @__PURE__ */new Date()\n    });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const {\n    accessToken,\n    endpointUrl,\n    ...otherArgs\n  } = args;\n  let {\n    model\n  } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options !== null && options !== void 0 ? options : {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = \"Bearer \".concat(accessToken);\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(\"\".concat(HF_HUB_URL, \"/api/tasks\"));\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return \"\".concat(HF_INFERENCE_API_BASE_URL, \"/pipeline/\").concat(task, \"/\").concat(model);\n    }\n    return \"\".concat(HF_INFERENCE_API_BASE_URL, \"/models/\").concat(model);\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...(otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs)\n    }),\n    ...(credentials && {\n      credentials\n    }),\n    signal: options === null || options === void 0 ? void 0 : options.signal\n  };\n  return {\n    url,\n    info\n  };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  var _options$fetch2, _response$headers$get2;\n  const {\n    url,\n    info\n  } = await makeRequestOptions(args, options);\n  const response = await ((_options$fetch2 = options === null || options === void 0 ? void 0 : options.fetch) !== null && _options$fetch2 !== void 0 ? _options$fetch2 : fetch)(url, info);\n  if ((options === null || options === void 0 ? void 0 : options.retry_on_error) !== false && response.status === 503 && !(options !== null && options !== void 0 && options.wait_for_model)) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    var _response$headers$get;\n    if ((_response$headers$get = response.headers.get(\"Content-Type\")) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options !== null && options !== void 0 && options.chatCompletion) {\n        throw new Error(\"Server \".concat(args.model, \" does not seem to support chat completion. Error: \").concat(output.error));\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if ((_response$headers$get2 = response.headers.get(\"Content-Type\")) !== null && _response$headers$get2 !== void 0 && _response$headers$get2.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage === null || onMessage === void 0 || onMessage(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  var _options$fetch3, _response$headers$get4;\n  const {\n    url,\n    info\n  } = await makeRequestOptions({\n    ...args,\n    stream: true\n  }, options);\n  const response = await ((_options$fetch3 = options === null || options === void 0 ? void 0 : options.fetch) !== null && _options$fetch3 !== void 0 ? _options$fetch3 : fetch)(url, info);\n  if ((options === null || options === void 0 ? void 0 : options.retry_on_error) !== false && response.status === 503 && !(options !== null && options !== void 0 && options.wait_for_model)) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    var _response$headers$get3;\n    if ((_response$headers$get3 = response.headers.get(\"Content-Type\")) !== null && _response$headers$get3 !== void 0 && _response$headers$get3.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options !== null && options !== void 0 && options.chatCompletion) {\n        throw new Error(\"Server \".concat(args.model, \" does not seem to support chat completion. Error: \").concat(output.error));\n      }\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(\"Server response contains error: \".concat(response.status));\n  }\n  if (!((_response$headers$get4 = response.headers.get(\"content-type\")) !== null && _response$headers$get4 !== void 0 && _response$headers$get4.startsWith(\"text/event-stream\"))) {\n    throw new Error(\"Server does not support event stream content type, it returned \" + response.headers.get(\"content-type\"));\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = event => {\n    events.push(event);\n  };\n  const onChunk = getLines(getMessages(() => {}, () => {}, onEvent));\n  try {\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\"Invalid inference output: \".concat(message, \". Use the 'request' method with the same parameters to do a custom call with no type checking.\"));\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.text) === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  var _await$request;\n  const res = (_await$request = await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  })) === null || _await$request === void 0 ? void 0 : _await$request[0];\n  if (typeof (res === null || res === void 0 ? void 0 : res.generated_text) !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach(byte => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...(defaultTask === \"sentence-similarity\" && {\n      forceTask: \"feature-extraction\"\n    })\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = function (arr, maxDepth) {\n    let curDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (curDepth > maxDepth) return false;\n    if (arr.every(x => Array.isArray(x))) {\n      return arr.every(x => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every(x => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...(defaultTask === \"feature-extraction\" && {\n      forceTask: \"sentence-similarity\"\n    })\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.summary_text) === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res === null || res === void 0 ? void 0 : res[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.aggregator) === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every(x => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every(coord => Array.isArray(coord) && coord.every(x => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  var _await$request2;\n  const res = (_await$request2 = await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  })) === null || _await$request2 === void 0 ? void 0 : _await$request2[0];\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.label) === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.generated_text) === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res === null || res === void 0 ? void 0 : res[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"token-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.translation_text) === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return (res === null || res === void 0 ? void 0 : res.length) === 1 ? res === null || res === void 0 ? void 0 : res[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"zero-shot-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => Array.isArray(x.labels) && x.labels.every(_label => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every(_score => typeof _score === \"number\") && typeof x.sequence === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res === null || res === void 0 ? void 0 : res.choices) && typeof (res === null || res === void 0 ? void 0 : res.created) === \"number\" && typeof (res === null || res === void 0 ? void 0 : res.id) === \"string\" && typeof (res === null || res === void 0 ? void 0 : res.model) === \"string\" && typeof (res === null || res === void 0 ? void 0 : res.system_fingerprint) === \"string\" && typeof (res === null || res === void 0 ? void 0 : res.usage) === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  var _toArray;\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = (_toArray = toArray(await request(reqArgs, {\n    ...options,\n    taskHint: \"document-question-answering\"\n  }))) === null || _toArray === void 0 ? void 0 : _toArray[0];\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.answer) === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  var _await$request3;\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = (_await$request3 = await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  })) === null || _await$request3 === void 0 ? void 0 : _await$request3[0];\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.answer) === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class HfInference {\n  constructor() {\n    let accessToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let defaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _defineProperty(this, \"accessToken\", void 0);\n    _defineProperty(this, \"defaultOptions\", void 0);\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn({\n          ...params,\n          accessToken\n        }, {\n          ...defaultOptions,\n          ...options\n        })\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl) {\n    let accessToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let defaultOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn({\n          ...params,\n          accessToken,\n          endpointUrl\n        }, {\n          ...defaultOptions,\n          ...options\n        })\n      });\n    }\n  }\n};\nexport { HfInference, HfInferenceEndpoint, InferenceOutputError, audioClassification, audioToAudio, automaticSpeechRecognition, chatCompletion, chatCompletionStream, documentQuestionAnswering, featureExtraction, fillMask, imageClassification, imageSegmentation, imageToImage, imageToText, objectDetection, questionAnswering, request, sentenceSimilarity, streamingRequest, summarization, tableQuestionAnswering, tabularClassification, tabularRegression, textClassification, textGeneration, textGenerationStream, textToImage, textToSpeech, tokenClassification, translation, visualQuestionAnswering, zeroShotClassification, zeroShotImageClassification };","map":{"version":3,"names":["__defProp","Object","defineProperty","__export","target","all","name","get","enumerable","tasks_exports","audioClassification","audioToAudio","automaticSpeechRecognition","chatCompletion","chatCompletionStream","documentQuestionAnswering","featureExtraction","fillMask","imageClassification","imageSegmentation","imageToImage","imageToText","objectDetection","questionAnswering","request","sentenceSimilarity","streamingRequest","summarization","tableQuestionAnswering","tabularClassification","tabularRegression","textClassification","textGeneration","textGenerationStream","textToImage","textToSpeech","tokenClassification","translation","visualQuestionAnswering","zeroShotClassification","zeroShotImageClassification","pick","o","props","assign","map","prop","typedInclude","arr","v","includes","omit","propsArr","Array","isArray","letsKeep","keys","filter","isUrl","modelOrUrl","test","startsWith","taskCache","Map","CACHE_DURATION","MAX_CACHE_ITEMS","HF_HUB_URL","getDefaultTask","model","accessToken","options","key","concat","cachedTask","date","Date","now","delete","_options$fetch","modelTask","fetch","headers","Authorization","then","resp","json","pipeline_tag","catch","task","set","size","next","value","HF_INFERENCE_API_BASE_URL","tasks","makeRequestOptions","args","endpointUrl","otherArgs","forceTask","includeCredentials","taskHint","wait_for_model","use_cache","dont_load_model","chatCompletion2","res","ok","taskInfo","models","id","Error","binary","data","url","TypeError","console","warn","endsWith","credentials","info","method","body","JSON","stringify","signal","_options$fetch2","_response$headers$get2","response","retry_on_error","status","_response$headers$get","output","error","blob","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","onChunk","bufLength","length","lineStart","lineEnd","subarray","getMessages","onId","onRetry","onMessage","message","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","event","retry","parseInt","isNaN","a","b","Uint8Array","_options$fetch3","_response$headers$get4","stream","_response$headers$get3","reader","getReader","events","onEvent","push","done","read","parse","releaseLock","InferenceOutputError","constructor","isValidOutput","every","x","label","score","text","Blob","mask","_await$request","generated_text","box","xmin","ymin","xmax","ymax","base64FromBytes","globalThis","Buffer","from","toString","bin","forEach","byte","String","fromCharCode","btoa","join","reqArgs","parameters","inputs","ArrayBuffer","arrayBuffer","image","defaultTask","isNumArrayRec","maxDepth","curDepth","arguments","undefined","sequence","token","token_str","answer","end","start","summary_text","aggregator","cells","coordinates","coord","_await$request2","toArray","obj","entity_group","word","translation_text","labels","_label","scores","_score","choices","created","system_fingerprint","usage","_toArray","question","_await$request3","HfInference","defaultOptions","_defineProperty","fn","entries","params","endpoint","HfInferenceEndpoint"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/client/node_modules/@huggingface/inference/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign(\n    {},\n    ...props.map((prop) => {\n      if (o[prop] !== void 0) {\n        return { [prop]: o[prop] };\n      }\n    })\n  );\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}\n    }).then((resp) => resp.json()).then((json) => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = { task: modelTask, date: /* @__PURE__ */ new Date() };\n    taskCache.set(key, { task: modelTask, date: /* @__PURE__ */ new Date() });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, endpointUrl, ...otherArgs } = args;\n  let { model } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs\n    }),\n    ...credentials && { credentials },\n    signal: options?.signal\n  };\n  return { url, info };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...defaultTask === \"sentence-similarity\" && { forceTask: \"feature-extraction\" }\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...defaultTask === \"feature-extraction\" && { forceTask: \"sentence-similarity\" }\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && typeof res?.system_fingerprint === \"string\" && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  )?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\nexport {\n  HfInference,\n  HfInferenceEndpoint,\n  InferenceOutputError,\n  audioClassification,\n  audioToAudio,\n  automaticSpeechRecognition,\n  chatCompletion,\n  chatCompletionStream,\n  documentQuestionAnswering,\n  featureExtraction,\n  fillMask,\n  imageClassification,\n  imageSegmentation,\n  imageToImage,\n  imageToText,\n  objectDetection,\n  questionAnswering,\n  request,\n  sentenceSimilarity,\n  streamingRequest,\n  summarization,\n  tableQuestionAnswering,\n  tabularClassification,\n  tabularRegression,\n  textClassification,\n  textGeneration,\n  textGenerationStream,\n  textToImage,\n  textToSpeech,\n  tokenClassification,\n  translation,\n  visualQuestionAnswering,\n  zeroShotClassification,\n  zeroShotImageClassification\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}