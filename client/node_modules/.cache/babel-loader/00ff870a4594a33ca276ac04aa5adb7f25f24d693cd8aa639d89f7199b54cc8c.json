{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.supportedMetrics = exports.Page = exports.setDefaultScreenshotOptions = void 0;\nconst rxjs_js_1 = require(\"../../third_party/rxjs/rxjs.js\");\nconst Errors_js_1 = require(\"../common/Errors.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst TimeoutSettings_js_1 = require(\"../common/TimeoutSettings.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst decorators_js_1 = require(\"../util/decorators.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\nconst locators_js_1 = require(\"./locators/locators.js\");\n/**\n * @internal\n */\nfunction setDefaultScreenshotOptions(options) {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n}\nexports.setDefaultScreenshotOptions = setDefaultScreenshotOptions;\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nlet Page = (() => {\n  let _classSuper = EventEmitter_js_1.EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _screenshot_decorators;\n  return class Page extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * @internal\n     */\n    _isDragging = (__runInitializers(this, _instanceExtraInitializers), false);\n    /**\n     * @internal\n     */\n    _timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();\n    #requestHandlers = new WeakMap();\n    #inflight$ = new rxjs_js_1.ReplaySubject(1);\n    /**\n     * @internal\n     */\n    constructor() {\n      super();\n      (0, util_js_1.fromEmitterEvent)(this, \"request\" /* PageEvent.Request */).pipe((0, rxjs_js_1.mergeMap)(originalRequest => {\n        return (0, rxjs_js_1.concat)((0, rxjs_js_1.of)(1), (0, rxjs_js_1.merge)((0, util_js_1.fromEmitterEvent)(this, \"requestfailed\" /* PageEvent.RequestFailed */), (0, util_js_1.fromEmitterEvent)(this, \"requestfinished\" /* PageEvent.RequestFinished */), (0, util_js_1.fromEmitterEvent)(this, \"response\" /* PageEvent.Response */).pipe((0, rxjs_js_1.map)(response => {\n          return response.request();\n        }))).pipe((0, rxjs_js_1.filter)(request => {\n          return request.id === originalRequest.id;\n        }), (0, rxjs_js_1.take)(1), (0, rxjs_js_1.map)(() => {\n          return -1;\n        })));\n      }), (0, rxjs_js_1.mergeScan)((acc, addend) => {\n        return (0, rxjs_js_1.of)(acc + addend);\n      }, 0), (0, rxjs_js_1.takeUntil)((0, util_js_1.fromEmitterEvent)(this, \"close\" /* PageEvent.Close */)), (0, rxjs_js_1.startWith)(0)).subscribe(this.#inflight$);\n    }\n    /**\n     * Listen to page events.\n     *\n     * @remarks\n     * This method exists to define event typings and handle proper wireup of\n     * cooperative request interception. Actual event listening and dispatching is\n     * delegated to {@link EventEmitter}.\n     *\n     * @internal\n     */\n    on(type, handler) {\n      if (type !== \"request\" /* PageEvent.Request */) {\n        return super.on(type, handler);\n      }\n      let wrapper = this.#requestHandlers.get(handler);\n      if (wrapper === undefined) {\n        wrapper = event => {\n          event.enqueueInterceptAction(() => {\n            return handler(event);\n          });\n        };\n        this.#requestHandlers.set(handler, wrapper);\n      }\n      return super.on(type, wrapper);\n    }\n    /**\n     * @internal\n     */\n    off(type, handler) {\n      if (type === \"request\" /* PageEvent.Request */) {\n        handler = this.#requestHandlers.get(handler) || handler;\n      }\n      return super.off(type, handler);\n    }\n    locator(selectorOrFunc) {\n      if (typeof selectorOrFunc === 'string') {\n        return locators_js_1.NodeLocator.create(this, selectorOrFunc);\n      } else {\n        return locators_js_1.FunctionLocator.create(this, selectorOrFunc);\n      }\n    }\n    /**\n     * A shortcut for {@link Locator.race} that does not require static imports.\n     *\n     * @internal\n     */\n    locatorRace(locators) {\n      return locators_js_1.Locator.race(locators);\n    }\n    /**\n     * Runs `document.querySelector` within the page. If no element matches the\n     * selector, the return value resolves to `null`.\n     *\n     * @param selector - A `selector` to query page for\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query page for.\n     */\n    async $(selector) {\n      return await this.mainFrame().$(selector);\n    }\n    /**\n     * The method runs `document.querySelectorAll` within the page. If no elements\n     * match the selector, the return value resolves to `[]`.\n     *\n     * @param selector - A `selector` to query page for\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n     */\n    async $$(selector) {\n      return await this.mainFrame().$$(selector);\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Page.evaluate | page.evaluate} and\n     * `page.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * If the function passed to `page.evaluateHandle` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle('document');\n     * ```\n     *\n     * @example\n     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle(() => document.body);\n     * const resultHandle = await page.evaluateHandle(\n     *   body => body.innerHTML,\n     *   aHandle\n     * );\n     * console.log(await resultHandle.jsonValue());\n     * await resultHandle.dispose();\n     * ```\n     *\n     * Most of the time this function returns a {@link JSHandle},\n     * but if `pageFunction` returns a reference to an element,\n     * you instead get an {@link ElementHandle} back:\n     *\n     * @example\n     *\n     * ```ts\n     * const button = await page.evaluateHandle(() =>\n     *   document.querySelector('button')\n     * );\n     * // can call `click` because `button` is an `ElementHandle`\n     * await button.click();\n     * ```\n     *\n     * The TypeScript definitions assume that `evaluateHandle` returns\n     * a `JSHandle`, but if you know it's going to return an\n     * `ElementHandle`, pass it as the generic argument:\n     *\n     * ```ts\n     * const button = await page.evaluateHandle<ElementHandle>(...);\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);\n      return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * This method runs `document.querySelector` within the page and passes the\n     * result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     *\n     * If no element is found matching `selector`, the method will throw an error.\n     *\n     * If `pageFunction` returns a promise `$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const searchValue = await page.$eval('#search', el => el.value);\n     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n     * const html = await page.$eval('.main-container', el => el.outerHTML);\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * const searchValue = await page.$eval(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const searchValue = await page.$eval<string>(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of `document.querySelector(selector)` as its\n     * first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$eval.name, pageFunction);\n      return await this.mainFrame().$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the page and passes the result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * // get the amount of divs on the page\n     * const divCount = await page.$$eval('div', divs => divs.length);\n     *\n     * // get the text content of all the `.options` elements:\n     * const options = await page.$$eval('div > span.options', options => {\n     *   return options.map(option => option.textContent);\n     * });\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element[]`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n     *   return elements.map(e => e.value);\n     * });\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const allInputValues = await page.$$eval<string[]>(\n     *   'input',\n     *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of\n     * `Array.from(document.querySelectorAll(selector))` as its first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$$eval.name, pageFunction);\n      return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired URL or content.\n     *\n     * @remarks\n     * Shortcut for\n     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n     *\n     * @param options - Options for the script.\n     * @returns An {@link ElementHandle | element handle} to the injected\n     * `<script>` element.\n     */\n    async addScriptTag(options) {\n      return await this.mainFrame().addScriptTag(options);\n    }\n    async addStyleTag(options) {\n      return await this.mainFrame().addStyleTag(options);\n    }\n    /**\n     * The page's URL.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.url | page.mainFrame().url()}.\n     */\n    url() {\n      return this.mainFrame().url();\n    }\n    /**\n     * The full HTML contents of the page, including the DOCTYPE.\n     */\n    async content() {\n      return await this.mainFrame().content();\n    }\n    /**\n     * Set the content of the page.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - Parameters that has some properties.\n     *\n     * @remarks\n     *\n     * The parameter `options` might have the following options.\n     *\n     * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n     *   to 30 seconds, pass `0` to disable timeout. The default value can be\n     *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n     *   {@link Page.setDefaultTimeout} methods.\n     *\n     * - `waitUntil`: When to consider setting markup succeeded, defaults to\n     *   `load`. Given an array of event strings, setting content is considered\n     *   to be successful after all events have been fired. Events can be\n     *   either:<br/>\n     * - `load` : consider setting content to be finished when the `load` event\n     *   is fired.<br/>\n     * - `domcontentloaded` : consider setting content to be finished when the\n     *   `DOMContentLoaded` event is fired.<br/>\n     * - `networkidle0` : consider setting content to be finished when there are\n     *   no more than 0 network connections for at least `500` ms.<br/>\n     * - `networkidle2` : consider setting content to be finished when there are\n     *   no more than 2 network connections for at least `500` ms.\n     */\n    async setContent(html, options) {\n      await this.mainFrame().setContent(html, options);\n    }\n    /**\n     * Navigates the page to the given `url`.\n     *\n     * @remarks\n     *\n     * Navigation to `about:blank` or navigation to the same URL with a different\n     * hash will succeed and return `null`.\n     *\n     * :::warning\n     *\n     * Headless mode doesn't support navigation to a PDF document. See the {@link\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n     * issue}.\n     *\n     * :::\n     *\n     * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n     *\n     * @param url - URL to navigate page to. The URL should include scheme, e.g.\n     * `https://`\n     * @param options - Options to configure waiting behavior.\n     * @returns A promise which resolves to the main resource response. In case of\n     * multiple redirects, the navigation will resolve with the response of the\n     * last redirect.\n     * @throws If:\n     *\n     * - there's an SSL error (e.g. in case of self-signed certificates).\n     * - target URL is invalid.\n     * - the timeout is exceeded during navigation.\n     * - the remote server does not respond or is unreachable.\n     * - the main resource failed to load.\n     *\n     * This method will not throw an error when any valid HTTP status code is\n     * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n     * Server Error\". The status code for such responses can be retrieved by\n     * calling {@link HTTPResponse.status}.\n     */\n    async goto(url, options) {\n      return await this.mainFrame().goto(url, options);\n    }\n    /**\n     * Waits for the page to navigate to a new URL or to reload. It is useful when\n     * you run code that will indirectly cause the page to navigate.\n     *\n     * @example\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(), // The promise resolves after navigation has finished\n     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n     * ]);\n     * ```\n     *\n     * @remarks\n     *\n     * Usage of the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n     * to change the URL is considered a navigation.\n     *\n     * @param options - Navigation parameters which might have the following\n     * properties:\n     * @returns A `Promise` which resolves to the main resource response.\n     *\n     * - In case of multiple redirects, the navigation will resolve with the\n     *   response of the last redirect.\n     * - In case of navigation to a different anchor or navigation due to History\n     *   API usage, the navigation will resolve with `null`.\n     */\n    async waitForNavigation(options = {}) {\n      return await this.mainFrame().waitForNavigation(options);\n    }\n    /**\n     * @param urlOrPredicate - A URL or predicate to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves to the matched request\n     * @example\n     *\n     * ```ts\n     * const firstRequest = await page.waitForRequest(\n     *   'https://example.com/resource'\n     * );\n     * const finalRequest = await page.waitForRequest(\n     *   request => request.url() === 'https://example.com'\n     * );\n     * return finalRequest.response()?.ok();\n     * ```\n     *\n     * @remarks\n     * Optional Waiting Parameters have:\n     *\n     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n     *   `0` to disable the timeout. The default value can be changed by using the\n     *   {@link Page.setDefaultTimeout} method.\n     */\n    waitForRequest(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout()\n      } = options;\n      if (typeof urlOrPredicate === 'string') {\n        const url = urlOrPredicate;\n        urlOrPredicate = request => {\n          return request.url() === url;\n        };\n      }\n      const observable$ = (0, util_js_1.fromEmitterEvent)(this, \"request\" /* PageEvent.Request */).pipe((0, util_js_1.filterAsync)(urlOrPredicate), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms), (0, util_js_1.fromEmitterEvent)(this, \"close\" /* PageEvent.Close */).pipe((0, rxjs_js_1.map)(() => {\n        throw new Errors_js_1.TargetCloseError('Page closed!');\n      }))));\n      return (0, rxjs_js_1.firstValueFrom)(observable$);\n    }\n    /**\n     * @param urlOrPredicate - A URL or predicate to wait for.\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves to the matched response.\n     * @example\n     *\n     * ```ts\n     * const firstResponse = await page.waitForResponse(\n     *   'https://example.com/resource'\n     * );\n     * const finalResponse = await page.waitForResponse(\n     *   response =>\n     *     response.url() === 'https://example.com' && response.status() === 200\n     * );\n     * const finalResponse = await page.waitForResponse(async response => {\n     *   return (await response.text()).includes('<html>');\n     * });\n     * return finalResponse.ok();\n     * ```\n     *\n     * @remarks\n     * Optional Parameter have:\n     *\n     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n     *   pass `0` to disable the timeout. The default value can be changed by using\n     *   the {@link Page.setDefaultTimeout} method.\n     */\n    waitForResponse(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout()\n      } = options;\n      if (typeof urlOrPredicate === 'string') {\n        const url = urlOrPredicate;\n        urlOrPredicate = response => {\n          return response.url() === url;\n        };\n      }\n      const observable$ = (0, util_js_1.fromEmitterEvent)(this, \"response\" /* PageEvent.Response */).pipe((0, util_js_1.filterAsync)(urlOrPredicate), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms), (0, util_js_1.fromEmitterEvent)(this, \"close\" /* PageEvent.Close */).pipe((0, rxjs_js_1.map)(() => {\n        throw new Errors_js_1.TargetCloseError('Page closed!');\n      }))));\n      return (0, rxjs_js_1.firstValueFrom)(observable$);\n    }\n    /**\n     * Waits for the network to be idle.\n     *\n     * @param options - Options to configure waiting behavior.\n     * @returns A promise which resolves once the network is idle.\n     */\n    waitForNetworkIdle(options = {}) {\n      return (0, rxjs_js_1.firstValueFrom)(this.waitForNetworkIdle$(options));\n    }\n    /**\n     * @internal\n     */\n    waitForNetworkIdle$(options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout(),\n        idleTime = util_js_1.NETWORK_IDLE_TIME,\n        concurrency = 0\n      } = options;\n      return this.#inflight$.pipe((0, rxjs_js_1.switchMap)(inflight => {\n        if (inflight > concurrency) {\n          return rxjs_js_1.EMPTY;\n        }\n        return (0, rxjs_js_1.timer)(idleTime);\n      }), (0, rxjs_js_1.map)(() => {}), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms), (0, util_js_1.fromEmitterEvent)(this, \"close\" /* PageEvent.Close */).pipe((0, rxjs_js_1.map)(() => {\n        throw new Errors_js_1.TargetCloseError('Page closed!');\n      }))));\n    }\n    /**\n     * Waits for a frame matching the given conditions to appear.\n     *\n     * @example\n     *\n     * ```ts\n     * const frame = await page.waitForFrame(async frame => {\n     *   return frame.name() === 'Test';\n     * });\n     * ```\n     */\n    async waitForFrame(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this.getDefaultTimeout()\n      } = options;\n      if ((0, util_js_1.isString)(urlOrPredicate)) {\n        urlOrPredicate = frame => {\n          return urlOrPredicate === frame.url();\n        };\n      }\n      return await (0, rxjs_js_1.firstValueFrom)((0, rxjs_js_1.merge)((0, util_js_1.fromEmitterEvent)(this, \"frameattached\" /* PageEvent.FrameAttached */), (0, util_js_1.fromEmitterEvent)(this, \"framenavigated\" /* PageEvent.FrameNavigated */), (0, rxjs_js_1.from)(this.frames())).pipe((0, util_js_1.filterAsync)(urlOrPredicate), (0, rxjs_js_1.first)(), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms), (0, util_js_1.fromEmitterEvent)(this, \"close\" /* PageEvent.Close */).pipe((0, rxjs_js_1.map)(() => {\n        throw new Errors_js_1.TargetCloseError('Page closed.');\n      })))));\n    }\n    /**\n     * Emulates a given device's metrics and user agent.\n     *\n     * To aid emulation, Puppeteer provides a list of known devices that can be\n     * via {@link KnownDevices}.\n     *\n     * @remarks\n     * This method is a shortcut for calling two methods:\n     * {@link Page.setUserAgent} and {@link Page.setViewport}.\n     *\n     * This method will resize the page. A lot of websites don't expect phones to\n     * change size, so you should emulate before navigating to the page.\n     *\n     * @example\n     *\n     * ```ts\n     * import {KnownDevices} from 'puppeteer';\n     * const iPhone = KnownDevices['iPhone 6'];\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   await page.emulate(iPhone);\n     *   await page.goto('https://www.google.com');\n     *   // other actions...\n     *   await browser.close();\n     * })();\n     * ```\n     */\n    async emulate(device) {\n      await Promise.all([this.setUserAgent(device.userAgent), this.setViewport(device.viewport)]);\n    }\n    /**\n     * Evaluates a function in the page's context and returns the result.\n     *\n     * If the function passed to `page.evaluate` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const result = await frame.evaluate(() => {\n     *   return Promise.resolve(8 * 7);\n     * });\n     * console.log(result); // prints \"56\"\n     * ```\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluate('1 + 2');\n     * ```\n     *\n     * To get the best TypeScript experience, you should pass in as the\n     * generic the type of `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluate(() => 2);\n     * ```\n     *\n     * @example\n     *\n     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n     * as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const bodyHandle = await page.$('body');\n     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n     * await bodyHandle.dispose();\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     *\n     * @returns the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);\n      return await this.mainFrame().evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async _maybeWriteBufferToFile(path, buffer) {\n      if (!path) {\n        return;\n      }\n      const fs = await (0, util_js_1.importFSPromises)();\n      await fs.writeFile(path, buffer);\n    }\n    /**\n     * Captures a screencast of this {@link Page | page}.\n     *\n     * @example\n     * Recording a {@link Page | page}:\n     *\n     * ```\n     * import puppeteer from 'puppeteer';\n     *\n     * // Launch a browser\n     * const browser = await puppeteer.launch();\n     *\n     * // Create a new page\n     * const page = await browser.newPage();\n     *\n     * // Go to your site.\n     * await page.goto(\"https://www.example.com\");\n     *\n     * // Start recording.\n     * const recorder = await page.screencast({path: 'recording.webm'});\n     *\n     * // Do something.\n     *\n     * // Stop recording.\n     * await recorder.stop();\n     *\n     * browser.close();\n     * ```\n     *\n     * @param options - Configures screencast behavior.\n     *\n     * @experimental\n     *\n     * @remarks\n     *\n     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n     *\n     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n     */\n    async screencast(options = {}) {\n      const [{\n        ScreenRecorder\n      }, [width, height, devicePixelRatio]] = await Promise.all([Promise.resolve().then(() => __importStar(require('../node/ScreenRecorder.js'))), this.#getNativePixelDimensions()]);\n      let crop;\n      if (options.crop) {\n        const {\n          x,\n          y,\n          width: cropWidth,\n          height: cropHeight\n        } = roundRectangle(normalizeRectangle(options.crop));\n        if (x < 0 || y < 0) {\n          throw new Error(`\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`);\n        }\n        if (cropWidth <= 0 || cropHeight <= 0) {\n          throw new Error(`\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`);\n        }\n        const viewportWidth = width / devicePixelRatio;\n        const viewportHeight = height / devicePixelRatio;\n        if (x + cropWidth > viewportWidth) {\n          throw new Error(`\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`);\n        }\n        if (y + cropHeight > viewportHeight) {\n          throw new Error(`\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`);\n        }\n        crop = {\n          x: x * devicePixelRatio,\n          y: y * devicePixelRatio,\n          width: cropWidth * devicePixelRatio,\n          height: cropHeight * devicePixelRatio\n        };\n      }\n      if (options.speed !== undefined && options.speed <= 0) {\n        throw new Error(`\\`speed\\` must be greater than 0.`);\n      }\n      if (options.scale !== undefined && options.scale <= 0) {\n        throw new Error(`\\`scale\\` must be greater than 0.`);\n      }\n      const recorder = new ScreenRecorder(this, width, height, {\n        ...options,\n        path: options.ffmpegPath,\n        crop\n      });\n      try {\n        await this._startScreencast();\n      } catch (error) {\n        void recorder.stop();\n        throw error;\n      }\n      if (options.path) {\n        const {\n          createWriteStream\n        } = await Promise.resolve().then(() => __importStar(require('fs')));\n        const stream = createWriteStream(options.path, 'binary');\n        recorder.pipe(stream);\n      }\n      return recorder;\n    }\n    #screencastSessionCount = 0;\n    #startScreencastPromise;\n    /**\n     * @internal\n     */\n    async _startScreencast() {\n      ++this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        this.#startScreencastPromise = this.mainFrame().client.send('Page.startScreencast', {\n          format: 'png'\n        }).then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n      }\n      await this.#startScreencastPromise;\n    }\n    /**\n     * @internal\n     */\n    async _stopScreencast() {\n      --this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        return;\n      }\n      this.#startScreencastPromise = undefined;\n      if (this.#screencastSessionCount === 0) {\n        await this.mainFrame().client.send('Page.stopScreencast');\n      }\n    }\n    /**\n     * Gets the native, non-emulated dimensions of the viewport.\n     */\n    async #getNativePixelDimensions() {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const viewport = this.viewport();\n        const stack = __addDisposableResource(env_1, new disposable_js_1.DisposableStack(), false);\n        if (viewport && viewport.deviceScaleFactor !== 0) {\n          await this.setViewport({\n            ...viewport,\n            deviceScaleFactor: 0\n          });\n          stack.defer(() => {\n            void this.setViewport(viewport).catch(util_js_1.debugError);\n          });\n        }\n        return await this.mainFrame().isolatedRealm().evaluate(() => {\n          return [window.visualViewport.width * window.devicePixelRatio, window.visualViewport.height * window.devicePixelRatio, window.devicePixelRatio];\n        });\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    async screenshot(userOptions = {}) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.bringToFront();\n        // TODO: use structuredClone after Node 16 support is dropped.\n        const options = {\n          ...userOptions,\n          clip: userOptions.clip ? {\n            ...userOptions.clip\n          } : undefined\n        };\n        if (options.type === undefined && options.path !== undefined) {\n          const filePath = options.path;\n          // Note we cannot use Node.js here due to browser compatibility.\n          const extension = filePath.slice(filePath.lastIndexOf('.') + 1).toLowerCase();\n          switch (extension) {\n            case 'png':\n              options.type = 'png';\n              break;\n            case 'jpeg':\n            case 'jpg':\n              options.type = 'jpeg';\n              break;\n            case 'webp':\n              options.type = 'webp';\n              break;\n          }\n        }\n        if (options.quality !== undefined) {\n          if (options.quality < 0 && options.quality > 100) {\n            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);\n          }\n          if (options.type === undefined || !['jpeg', 'webp'].includes(options.type)) {\n            throw new Error(`${options.type ?? 'png'} screenshots do not support 'quality'.`);\n          }\n        }\n        if (options.clip) {\n          if (options.clip.width <= 0) {\n            throw new Error(\"'width' in 'clip' must be positive.\");\n          }\n          if (options.clip.height <= 0) {\n            throw new Error(\"'height' in 'clip' must be positive.\");\n          }\n        }\n        setDefaultScreenshotOptions(options);\n        const stack = __addDisposableResource(env_2, new disposable_js_1.AsyncDisposableStack(), true);\n        if (options.clip) {\n          if (options.fullPage) {\n            throw new Error(\"'clip' and 'fullPage' are mutually exclusive\");\n          }\n          options.clip = roundRectangle(normalizeRectangle(options.clip));\n        } else {\n          if (options.fullPage) {\n            // If `captureBeyondViewport` is `false`, then we set the viewport to\n            // capture the full page. Note this may be affected by on-page CSS and\n            // JavaScript.\n            if (!options.captureBeyondViewport) {\n              const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {\n                const element = document.documentElement;\n                return {\n                  width: element.scrollWidth,\n                  height: element.scrollHeight\n                };\n              });\n              const viewport = this.viewport();\n              await this.setViewport({\n                ...viewport,\n                ...scrollDimensions\n              });\n              stack.defer(async () => {\n                if (viewport) {\n                  await this.setViewport(viewport).catch(util_js_1.debugError);\n                } else {\n                  await this.setViewport({\n                    width: 0,\n                    height: 0\n                  }).catch(util_js_1.debugError);\n                }\n              });\n            }\n          } else {\n            options.captureBeyondViewport = false;\n          }\n        }\n        const data = await this._screenshot(options);\n        if (options.encoding === 'base64') {\n          return data;\n        }\n        const buffer = Buffer.from(data, 'base64');\n        await this._maybeWriteBufferToFile(options.path, buffer);\n        return buffer;\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_2);\n        if (result_1) await result_1;\n      }\n    }\n    /**\n     * The page's title\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n     */\n    async title() {\n      return await this.mainFrame().title();\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse} to click in the center of the\n     * element. If there's no element matching `selector`, the method throws an\n     * error.\n     *\n     * @remarks\n     *\n     * Bear in mind that if `click()` triggers a navigation event and\n     * there's a separate `page.waitForNavigation()` promise to be resolved, you\n     * may end up with a race condition that yields unexpected results. The\n     * correct pattern for click and wait for navigation is the following:\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   page.click(selector, clickOptions),\n     * ]);\n     * ```\n     *\n     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n     * @param selector - A `selector` to search for element to click. If there are\n     * multiple elements satisfying the `selector`, the first will be clicked\n     * @param options - `Object`\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully clicked. The Promise will be rejected if there is no element\n     * matching `selector`.\n     */\n    click(selector, options) {\n      return this.mainFrame().click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it. If there's no\n     * element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n     * of an element to focus. If there are multiple elements satisfying the\n     * selector, the first will be focused.\n     * @returns Promise which resolves when the element matching selector is\n     * successfully focused. The promise will be rejected if there is no element\n     * matching selector.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n     */\n    focus(selector) {\n      return this.mainFrame().focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse}\n     * to hover over the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to search for element to hover. If there are multiple elements satisfying\n     * the selector, the first will be hovered.\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully hovered. Promise gets rejected if there's no element matching\n     * `selector`.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n     */\n    hover(selector) {\n      return this.mainFrame().hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * page.select('select#colors', 'blue'); // single selection\n     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n     * to query the page for\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first one\n     * is taken into account.\n     * @returns\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.select | page.mainFrame().select()}\n     */\n    select(selector, ...values) {\n      return this.mainFrame().select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.touchscreen}\n     * to tap in the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n     * to search for element to tap. If there are multiple elements satisfying the\n     * selector, the first will be tapped.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n     */\n    tap(selector) {\n      return this.mainFrame().tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n     * in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n     * @example\n     *\n     * ```ts\n     * await page.type('#mytextarea', 'Hello');\n     * // Types instantly\n     * await page.type('#mytextarea', 'World', {delay: 100});\n     * // Types slower, like a user\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * of an element to type into. If there are multiple elements satisfying the\n     * selector, the first will be used.\n     * @param text - A text to type into a focused element.\n     * @param options - have property `delay` which is the Time to wait between\n     * key presses in milliseconds. Defaults to `0`.\n     * @returns\n     */\n    type(selector, text, options) {\n      return this.mainFrame().type(selector, text, options);\n    }\n    /**\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately. If\n     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * @example\n     * This method works across navigations:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * of an element to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves when element specified by selector string\n     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n     * selector is not found in DOM.\n     *\n     * @remarks\n     * The optional Parameter in Arguments `options` are:\n     *\n     * - `visible`: A boolean wait for element to be present in DOM and to be\n     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n     *   properties. Defaults to `false`.\n     *\n     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n     *   `false`.\n     *\n     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n     *   by using the {@link Page.setDefaultTimeout} method.\n     */\n    async waitForSelector(selector, options = {}) {\n      return await this.mainFrame().waitForSelector(selector, options);\n    }\n    /**\n     * Waits for the provided function, `pageFunction`, to return a truthy value when\n     * evaluated in the page's context.\n     *\n     * @example\n     * {@link Page.waitForFunction} can be used to observe a viewport size change:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n     *   await page.setViewport({width: 50, height: 50});\n     *   await watchDog;\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @example\n     * Arguments can be passed from Node.js to `pageFunction`:\n     *\n     * ```ts\n     * const selector = '.foo';\n     * await page.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {},\n     *   selector\n     * );\n     * ```\n     *\n     * @example\n     * The provided `pageFunction` can be asynchronous:\n     *\n     * ```ts\n     * const username = 'github-username';\n     * await page.waitForFunction(\n     *   async username => {\n     *     const githubResponse = await fetch(\n     *       `https://api.github.com/users/${username}`\n     *     );\n     *     const githubUser = await githubResponse.json();\n     *     // show the avatar\n     *     const img = document.createElement('img');\n     *     img.src = githubUser.avatar_url;\n     *     // wait 3 seconds\n     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n     *     img.remove();\n     *   },\n     *   {},\n     *   username\n     * );\n     * ```\n     *\n     * @param pageFunction - Function to be evaluated in browser context until it returns a\n     * truthy value.\n     * @param options - Options for configuring waiting behavior.\n     */\n    waitForFunction(pageFunction, options, ...args) {\n      return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n    }\n    /** @internal */\n    [(_screenshot_decorators = [(0, decorators_js_1.guarded)(function () {\n      return this.browser();\n    })], disposable_js_1.disposeSymbol)]() {\n      return void this.close().catch(util_js_1.debugError);\n    }\n    /** @internal */\n    [disposable_js_1.asyncDisposeSymbol]() {\n      return this.close();\n    }\n  };\n})();\nexports.Page = Page;\n/**\n * @internal\n */\nexports.supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle(clip) {\n  return {\n    ...clip,\n    ...(clip.width < 0 ? {\n      x: clip.x + clip.width,\n      width: -clip.width\n    } : {\n      x: clip.x,\n      width: clip.width\n    }),\n    ...(clip.height < 0 ? {\n      y: clip.y + clip.height,\n      height: -clip.height\n    } : {\n      y: clip.y,\n      height: clip.height\n    })\n  };\n}\nfunction roundRectangle(clip) {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {\n    ...clip,\n    x,\n    y,\n    width,\n    height\n  };\n}","map":{"version":3,"names":["rxjs_js_1","require","Errors_js_1","EventEmitter_js_1","TimeoutSettings_js_1","util_js_1","decorators_js_1","disposable_js_1","locators_js_1","setDefaultScreenshotOptions","options","optimizeForSpeed","type","fromSurface","fullPage","omitBackground","encoding","captureBeyondViewport","exports","Page","EventEmitter","_classSuper","__esDecorate","_screenshot_decorators","kind","name","static","private","access","has","obj","get","screenshot","metadata","_metadata","_instanceExtraInitializers","_isDragging","__runInitializers","_timeoutSettings","TimeoutSettings","requestHandlers","WeakMap","inflight$","ReplaySubject","constructor","fromEmitterEvent","pipe","mergeMap","originalRequest","concat","of","merge","map","response","request","filter","id","take","mergeScan","acc","addend","takeUntil","startWith","subscribe","on","handler","wrapper","undefined","event","enqueueInterceptAction","set","off","locator","selectorOrFunc","NodeLocator","create","FunctionLocator","locatorRace","locators","Locator","race","$","selector","mainFrame","$$","evaluateHandle","pageFunction","args","withSourcePuppeteerURLIfNone","$eval","$$eval","addScriptTag","addStyleTag","url","content","setContent","html","goto","waitForNavigation","waitForRequest","urlOrPredicate","timeout","ms","observable$","filterAsync","raceWith","TargetCloseError","firstValueFrom","waitForResponse","waitForNetworkIdle","waitForNetworkIdle$","idleTime","NETWORK_IDLE_TIME","concurrency","switchMap","inflight","EMPTY","timer","waitForFrame","getDefaultTimeout","isString","frame","from","frames","first","emulate","device","Promise","all","setUserAgent","userAgent","setViewport","viewport","evaluate","_maybeWriteBufferToFile","path","buffer","fs","importFSPromises","writeFile","screencast","ScreenRecorder","width","height","devicePixelRatio","getNativePixelDimensions","crop","x","y","cropWidth","cropHeight","roundRectangle","normalizeRectangle","Error","viewportWidth","viewportHeight","speed","scale","recorder","ffmpegPath","_startScreencast","error","stop","createWriteStream","resolve","then","__importStar","stream","screencastSessionCount","startScreencastPromise","client","send","format","once","_stopScreencast","#getNativePixelDimensions","stack","__addDisposableResource","env_1","DisposableStack","deviceScaleFactor","defer","catch","debugError","isolatedRealm","window","visualViewport","userOptions","bringToFront","clip","filePath","extension","slice","lastIndexOf","toLowerCase","quality","includes","env_2","AsyncDisposableStack","scrollDimensions","element","document","documentElement","scrollWidth","scrollHeight","data","_screenshot","Buffer","title","click","focus","hover","select","values","tap","text","waitForSelector","waitForFunction","guarded","browser","disposeSymbol","close","asyncDisposeSymbol","supportedMetrics","Set","Math","round"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/node_modules/puppeteer-core/src/api/Page.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {\n  concat,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  from,\n  map,\n  merge,\n  mergeMap,\n  mergeScan,\n  of,\n  raceWith,\n  ReplaySubject,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n  timer,\n  type Observable,\n} from '../../third_party/rxjs/rxjs.js';\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {Accessibility} from '../cdp/Accessibility.js';\nimport type {Coverage} from '../cdp/Coverage.js';\nimport type {DeviceRequestPrompt} from '../cdp/DeviceRequestPrompt.js';\nimport type {NetworkConditions} from '../cdp/NetworkManager.js';\nimport type {Tracing} from '../cdp/Tracing.js';\nimport type {ConsoleMessage} from '../common/ConsoleMessage.js';\nimport type {\n  Cookie,\n  CookieParam,\n  DeleteCookiesRequest,\n} from '../common/Cookie.js';\nimport type {Device} from '../common/Device.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {\n  EventEmitter,\n  type EventsWithWildcard,\n  type EventType,\n  type Handler,\n} from '../common/EventEmitter.js';\nimport type {FileChooser} from '../common/FileChooser.js';\nimport type {PDFOptions} from '../common/PDFOptions.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {\n  Awaitable,\n  AwaitablePredicate,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {\n  debugError,\n  fromEmitterEvent,\n  filterAsync,\n  importFSPromises,\n  isString,\n  NETWORK_IDLE_TIME,\n  timeout,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport type {Viewport} from '../common/Viewport.js';\nimport type {ScreenRecorder} from '../node/ScreenRecorder.js';\nimport {guarded} from '../util/decorators.js';\nimport {\n  AsyncDisposableStack,\n  asyncDisposeSymbol,\n  DisposableStack,\n  disposeSymbol,\n} from '../util/disposable.js';\n\nimport type {Browser} from './Browser.js';\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {CDPSession} from './CDPSession.js';\nimport type {Dialog} from './Dialog.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from './ElementHandle.js';\nimport type {\n  Frame,\n  FrameAddScriptTagOptions,\n  FrameAddStyleTagOptions,\n  FrameWaitForFunctionOptions,\n  GoToOptions,\n  WaitForOptions,\n} from './Frame.js';\nimport type {\n  Keyboard,\n  KeyboardTypeOptions,\n  Mouse,\n  Touchscreen,\n} from './Input.js';\nimport type {JSHandle} from './JSHandle.js';\nimport {\n  FunctionLocator,\n  Locator,\n  NodeLocator,\n  type AwaitedLocator,\n} from './locators/locators.js';\nimport type {Target} from './Target.js';\nimport type {WebWorker} from './WebWorker.js';\n\n/**\n * @public\n */\nexport interface Metrics {\n  Timestamp?: number;\n  Documents?: number;\n  Frames?: number;\n  JSEventListeners?: number;\n  Nodes?: number;\n  LayoutCount?: number;\n  RecalcStyleCount?: number;\n  LayoutDuration?: number;\n  RecalcStyleDuration?: number;\n  ScriptDuration?: number;\n  TaskDuration?: number;\n  JSHeapUsedSize?: number;\n  JSHeapTotalSize?: number;\n}\n\n/**\n * @public\n */\nexport interface Credentials {\n  username: string;\n  password: string;\n}\n\n/**\n * @public\n */\nexport interface WaitForNetworkIdleOptions extends WaitTimeoutOptions {\n  /**\n   * Time (in milliseconds) the network should be idle.\n   *\n   * @defaultValue `500`\n   */\n  idleTime?: number;\n  /**\n   * Maximum number concurrent of network connections to be considered inactive.\n   *\n   * @defaultValue `0`\n   */\n  concurrency?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitTimeoutOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} method.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitForSelectorOptions {\n  /**\n   * Wait for the selected element to be present in DOM and to be visible, i.e.\n   * to not have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  visible?: boolean;\n  /**\n   * Wait for the selected element to not be found in the DOM or to be hidden,\n   * i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  hidden?: boolean;\n  /**\n   * Maximum time to wait in milliseconds. Pass `0` to disable timeout.\n   *\n   * The default value can be changed by using {@link Page.setDefaultTimeout}\n   *\n   * @defaultValue `30_000` (30 seconds)\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForSelector call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface GeolocationOptions {\n  /**\n   * Latitude between `-90` and `90`.\n   */\n  longitude: number;\n  /**\n   * Longitude between `-180` and `180`.\n   */\n  latitude: number;\n  /**\n   * Optional non-negative accuracy value.\n   */\n  accuracy?: number;\n}\n\n/**\n * @public\n */\nexport interface MediaFeature {\n  name: string;\n  value: string;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotClip extends BoundingBox {\n  /**\n   * @defaultValue `1`\n   */\n  scale?: number;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotOptions {\n  /**\n   * @defaultValue `false`\n   */\n  optimizeForSpeed?: boolean;\n  /**\n   * @defaultValue `'png'`\n   */\n  type?: 'png' | 'jpeg' | 'webp';\n  /**\n   * Quality of the image, between 0-100. Not applicable to `png` images.\n   */\n  quality?: number;\n  /**\n   * Capture the screenshot from the surface, rather than the view.\n   *\n   * @defaultValue `true`\n   */\n  fromSurface?: boolean;\n  /**\n   * When `true`, takes a screenshot of the full page.\n   *\n   * @defaultValue `false`\n   */\n  fullPage?: boolean;\n  /**\n   * Hides default white background and allows capturing screenshots with transparency.\n   *\n   * @defaultValue `false`\n   */\n  omitBackground?: boolean;\n  /**\n   * The file path to save the image to. The screenshot type will be inferred\n   * from file extension. If path is a relative path, then it is resolved\n   * relative to current working directory. If no path is provided, the image\n   * won't be saved to the disk.\n   */\n  path?: string;\n  /**\n   * Specifies the region of the page/element to clip.\n   */\n  clip?: ScreenshotClip;\n  /**\n   * Encoding of the image.\n   *\n   * @defaultValue `'binary'`\n   */\n  encoding?: 'base64' | 'binary';\n  /**\n   * Capture the screenshot beyond the viewport.\n   *\n   * @defaultValue `false` if there is no `clip`. `true` otherwise.\n   */\n  captureBeyondViewport?: boolean;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ScreencastOptions {\n  /**\n   * File path to save the screencast to.\n   */\n  path?: `${string}.webm`;\n  /**\n   * Specifies the region of the viewport to crop.\n   */\n  crop?: BoundingBox;\n  /**\n   * Scales the output video.\n   *\n   * For example, `0.5` will shrink the width and height of the output video by\n   * half. `2` will double the width and height of the output video.\n   *\n   * @defaultValue `1`\n   */\n  scale?: number;\n  /**\n   * Specifies the speed to record at.\n   *\n   * For example, `0.5` will slowdown the output video by 50%. `2` will double the\n   * speed of the output video.\n   *\n   * @defaultValue `1`\n   */\n  speed?: number;\n  /**\n   * Path to the [ffmpeg](https://ffmpeg.org/).\n   *\n   * Required if `ffmpeg` is not in your PATH.\n   */\n  ffmpegPath?: string;\n}\n\n/**\n * All the events that a page instance may emit.\n *\n * @public\n */\nexport const enum PageEvent {\n  /**\n   * Emitted when the page closes.\n   */\n  Close = 'close',\n  /**\n   * Emitted when JavaScript within the page calls one of console API methods,\n   * e.g. `console.log` or `console.dir`. Also emitted if the page throws an\n   * error or a warning.\n   *\n   * @remarks\n   * A `console` event provides a {@link ConsoleMessage} representing the\n   * console message that was logged.\n   *\n   * @example\n   * An example of handling `console` event:\n   *\n   * ```ts\n   * page.on('console', msg => {\n   *   for (let i = 0; i < msg.args().length; ++i)\n   *     console.log(`${i}: ${msg.args()[i]}`);\n   * });\n   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));\n   * ```\n   */\n  Console = 'console',\n  /**\n   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`,\n   * `confirm` or `beforeunload`. Puppeteer can respond to the dialog via\n   * {@link Dialog.accept} or {@link Dialog.dismiss}.\n   */\n  Dialog = 'dialog',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded | DOMContentLoaded }\n   * event is dispatched.\n   */\n  DOMContentLoaded = 'domcontentloaded',\n  /**\n   * Emitted when the page crashes. Will contain an `Error`.\n   */\n  Error = 'error',\n  /** Emitted when a frame is attached. Will contain a {@link Frame}. */\n  FrameAttached = 'frameattached',\n  /** Emitted when a frame is detached. Will contain a {@link Frame}. */\n  FrameDetached = 'framedetached',\n  /**\n   * Emitted when a frame is navigated to a new URL. Will contain a\n   * {@link Frame}.\n   */\n  FrameNavigated = 'framenavigated',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/load | load}\n   * event is dispatched.\n   */\n  Load = 'load',\n  /**\n   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For\n   * the list of metrics see {@link Page.metrics | page.metrics}.\n   *\n   * @remarks\n   * Contains an object with two properties:\n   *\n   * - `title`: the title passed to `console.timeStamp`\n   * - `metrics`: object containing metrics as key/value pairs. The values will\n   *   be `number`s.\n   */\n  Metrics = 'metrics',\n  /**\n   * Emitted when an uncaught exception happens within the page. Contains an\n   * `Error`.\n   */\n  PageError = 'pageerror',\n  /**\n   * Emitted when the page opens a new tab or window.\n   *\n   * Contains a {@link Page} corresponding to the popup window.\n   *\n   * @example\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.click('a[target=_blank]'),\n   * ]);\n   * ```\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.evaluate(() => window.open('https://example.com')),\n   * ]);\n   * ```\n   */\n  Popup = 'popup',\n  /**\n   * Emitted when a page issues a request and contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * The object is readonly. See {@link Page.setRequestInterception} for\n   * intercepting and mutating requests.\n   */\n  Request = 'request',\n  /**\n   * Emitted when a request ended up loading from cache. Contains a\n   * {@link HTTPRequest}.\n   *\n   * @remarks\n   * For certain requests, might contain undefined.\n   * {@link https://crbug.com/750469}\n   */\n  RequestServedFromCache = 'requestservedfromcache',\n  /**\n   * Emitted when a request fails, for example by timing out.\n   *\n   * Contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * HTTP Error responses, such as 404 or 503, are still successful responses\n   * from HTTP standpoint, so request will complete with `requestfinished` event\n   * and not with `requestfailed`.\n   */\n  RequestFailed = 'requestfailed',\n  /**\n   * Emitted when a request finishes successfully. Contains a\n   * {@link HTTPRequest}.\n   */\n  RequestFinished = 'requestfinished',\n  /**\n   * Emitted when a response is received. Contains a {@link HTTPResponse}.\n   */\n  Response = 'response',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is spawned by the page.\n   */\n  WorkerCreated = 'workercreated',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is destroyed by the page.\n   */\n  WorkerDestroyed = 'workerdestroyed',\n}\n\n/**\n * Denotes the objects received by callback functions for page events.\n *\n * See {@link PageEvent} for more detail on the events and when they are\n * emitted.\n *\n * @public\n */\nexport interface PageEvents extends Record<EventType, unknown> {\n  [PageEvent.Close]: undefined;\n  [PageEvent.Console]: ConsoleMessage;\n  [PageEvent.Dialog]: Dialog;\n  [PageEvent.DOMContentLoaded]: undefined;\n  [PageEvent.Error]: Error;\n  [PageEvent.FrameAttached]: Frame;\n  [PageEvent.FrameDetached]: Frame;\n  [PageEvent.FrameNavigated]: Frame;\n  [PageEvent.Load]: undefined;\n  [PageEvent.Metrics]: {title: string; metrics: Metrics};\n  [PageEvent.PageError]: Error;\n  [PageEvent.Popup]: Page | null;\n  [PageEvent.Request]: HTTPRequest;\n  [PageEvent.Response]: HTTPResponse;\n  [PageEvent.RequestFailed]: HTTPRequest;\n  [PageEvent.RequestFinished]: HTTPRequest;\n  [PageEvent.RequestServedFromCache]: HTTPRequest;\n  [PageEvent.WorkerCreated]: WebWorker;\n  [PageEvent.WorkerDestroyed]: WebWorker;\n}\n\n/**\n * @public\n */\nexport interface NewDocumentScriptEvaluation {\n  identifier: string;\n}\n\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options: ScreenshotOptions): void {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n}\n\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nexport abstract class Page extends EventEmitter<PageEvents> {\n  /**\n   * @internal\n   */\n  _isDragging = false;\n  /**\n   * @internal\n   */\n  _timeoutSettings = new TimeoutSettings();\n\n  #requestHandlers = new WeakMap<Handler<HTTPRequest>, Handler<HTTPRequest>>();\n\n  #inflight$ = new ReplaySubject<number>(1);\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n\n    fromEmitterEvent(this, PageEvent.Request)\n      .pipe(\n        mergeMap(originalRequest => {\n          return concat(\n            of(1),\n            merge(\n              fromEmitterEvent(this, PageEvent.RequestFailed),\n              fromEmitterEvent(this, PageEvent.RequestFinished),\n              fromEmitterEvent(this, PageEvent.Response).pipe(\n                map(response => {\n                  return response.request();\n                })\n              )\n            ).pipe(\n              filter(request => {\n                return request.id === originalRequest.id;\n              }),\n              take(1),\n              map(() => {\n                return -1;\n              })\n            )\n          );\n        }),\n        mergeScan((acc, addend) => {\n          return of(acc + addend);\n        }, 0),\n        takeUntil(fromEmitterEvent(this, PageEvent.Close)),\n        startWith(0)\n      )\n      .subscribe(this.#inflight$);\n  }\n\n  /**\n   * `true` if the service worker are being bypassed, `false` otherwise.\n   */\n  abstract isServiceWorkerBypassed(): boolean;\n\n  /**\n   * `true` if drag events are being intercepted, `false` otherwise.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page.mouse}).\n   */\n  abstract isDragInterceptionEnabled(): boolean;\n\n  /**\n   * `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n  abstract isJavaScriptEnabled(): boolean;\n\n  /**\n   * Listen to page events.\n   *\n   * @remarks\n   * This method exists to define event typings and handle proper wireup of\n   * cooperative request interception. Actual event listening and dispatching is\n   * delegated to {@link EventEmitter}.\n   *\n   * @internal\n   */\n  override on<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type !== PageEvent.Request) {\n      return super.on(type, handler);\n    }\n    let wrapper = this.#requestHandlers.get(\n      handler as (event: PageEvents[PageEvent.Request]) => void\n    );\n    if (wrapper === undefined) {\n      wrapper = (event: HTTPRequest) => {\n        event.enqueueInterceptAction(() => {\n          return handler(event as EventsWithWildcard<PageEvents>[K]);\n        });\n      };\n      this.#requestHandlers.set(\n        handler as (event: PageEvents[PageEvent.Request]) => void,\n        wrapper\n      );\n    }\n    return super.on(\n      type,\n      wrapper as (event: EventsWithWildcard<PageEvents>[K]) => void\n    );\n  }\n\n  /**\n   * @internal\n   */\n  override off<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type === PageEvent.Request) {\n      handler =\n        (this.#requestHandlers.get(\n          handler as (\n            event: EventsWithWildcard<PageEvents>[PageEvent.Request]\n          ) => void\n        ) as (event: EventsWithWildcard<PageEvents>[K]) => void) || handler;\n    }\n    return super.off(type, handler);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers file\n   * choosing.\n   *\n   * :::caution\n   *\n   * This must be called before the file chooser is launched. It will not return\n   * a currently active file chooser.\n   *\n   * :::\n   *\n   * @remarks\n   * In the \"headful\" browser, this method results in the native file picker\n   * dialog `not showing up` for the user.\n   *\n   * @example\n   * The following example clicks a button that issues a file chooser\n   * and then responds with `/tmp/myfile.pdf` as if a user has selected this file.\n   *\n   * ```ts\n   * const [fileChooser] = await Promise.all([\n   *   page.waitForFileChooser(),\n   *   page.click('#upload-file-button'),\n   *   // some button that triggers file selection\n   * ]);\n   * await fileChooser.accept(['/tmp/myfile.pdf']);\n   * ```\n   */\n  abstract waitForFileChooser(\n    options?: WaitTimeoutOptions\n  ): Promise<FileChooser>;\n\n  /**\n   * Sets the page's geolocation.\n   *\n   * @remarks\n   * Consider using {@link BrowserContext.overridePermissions} to grant\n   * permissions for the page to read its geolocation.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n   * ```\n   */\n  abstract setGeolocation(options: GeolocationOptions): Promise<void>;\n\n  /**\n   * A target this page was created from.\n   *\n   * @deprecated Use {@link Page.createCDPSession} directly.\n   */\n  abstract target(): Target;\n\n  /**\n   * Get the browser the page belongs to.\n   */\n  abstract browser(): Browser;\n\n  /**\n   * Get the browser context that the page belongs to.\n   */\n  abstract browserContext(): BrowserContext;\n\n  /**\n   * The page's main frame.\n   *\n   * @remarks\n   * Page is guaranteed to have a main frame which persists during navigations.\n   */\n  abstract mainFrame(): Frame;\n\n  /**\n   * Creates a Chrome Devtools Protocol session attached to the page.\n   */\n  abstract createCDPSession(): Promise<CDPSession>;\n\n  /**\n   * {@inheritDoc Keyboard}\n   */\n  abstract get keyboard(): Keyboard;\n\n  /**\n   * {@inheritDoc Touchscreen}\n   */\n  abstract get touchscreen(): Touchscreen;\n\n  /**\n   * {@inheritDoc Coverage}\n   */\n  abstract get coverage(): Coverage;\n\n  /**\n   * {@inheritDoc Tracing}\n   */\n  abstract get tracing(): Tracing;\n\n  /**\n   * {@inheritDoc Accessibility}\n   */\n  abstract get accessibility(): Accessibility;\n\n  /**\n   * An array of all frames attached to the page.\n   */\n  abstract frames(): Frame[];\n\n  /**\n   * All of the dedicated {@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n   * WebWorkers} associated with the page.\n   *\n   * @remarks\n   * This does not contain ServiceWorkers\n   */\n  abstract workers(): WebWorker[];\n\n  /**\n   * Activating request interception enables {@link HTTPRequest.abort},\n   * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods. This\n   * provides the capability to modify network requests that are made by a page.\n   *\n   * Once request interception is enabled, every request will stall unless it's\n   * continued, responded or aborted; or completed using the browser cache.\n   *\n   * See the\n   * {@link https://pptr.dev/next/guides/request-interception|Request interception guide}\n   * for more details.\n   *\n   * @example\n   * An example of a naïve request interceptor that aborts all image requests:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.setRequestInterception(true);\n   *   page.on('request', interceptedRequest => {\n   *     if (\n   *       interceptedRequest.url().endsWith('.png') ||\n   *       interceptedRequest.url().endsWith('.jpg')\n   *     )\n   *       interceptedRequest.abort();\n   *     else interceptedRequest.continue();\n   *   });\n   *   await page.goto('https://example.com');\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param value - Whether to enable request interception.\n   */\n  abstract setRequestInterception(value: boolean): Promise<void>;\n\n  /**\n   * Toggles ignoring of service worker for each request.\n   *\n   * @param bypass - Whether to bypass service worker and load from network.\n   */\n  abstract setBypassServiceWorker(bypass: boolean): Promise<void>;\n\n  /**\n   * @param enabled - Whether to enable drag interception.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page.mouse}).\n   */\n  abstract setDragInterception(enabled: boolean): Promise<void>;\n\n  /**\n   * Sets the network connection to offline.\n   *\n   * It does not change the parameters used in {@link Page.emulateNetworkConditions}\n   *\n   * @param enabled - When `true`, enables offline mode for the page.\n   */\n  abstract setOfflineMode(enabled: boolean): Promise<void>;\n\n  /**\n   * This does not affect WebSockets and WebRTC PeerConnections (see\n   * https://crbug.com/563644). To set the page offline, you can use\n   * {@link Page.setOfflineMode}.\n   *\n   * A list of predefined network conditions can be used by importing\n   * {@link PredefinedNetworkConditions}.\n   *\n   * @example\n   *\n   * ```ts\n   * import {PredefinedNetworkConditions} from 'puppeteer';\n   * const slow3G = PredefinedNetworkConditions['Slow 3G'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulateNetworkConditions(slow3G);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param networkConditions - Passing `null` disables network condition\n   * emulation.\n   */\n  abstract emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void>;\n\n  /**\n   * This setting will change the default maximum navigation time for the\n   * following methods and related shortcuts:\n   *\n   * - {@link Page.goBack | page.goBack(options)}\n   *\n   * - {@link Page.goForward | page.goForward(options)}\n   *\n   * - {@link Page.goto | page.goto(url,options)}\n   *\n   * - {@link Page.reload | page.reload(options)}\n   *\n   * - {@link Page.setContent | page.setContent(html,options)}\n   *\n   * - {@link Page.waitForNavigation | page.waitForNavigation(options)}\n   *   @param timeout - Maximum navigation time in milliseconds.\n   */\n  abstract setDefaultNavigationTimeout(timeout: number): void;\n\n  /**\n   * @param timeout - Maximum time in milliseconds.\n   */\n  abstract setDefaultTimeout(timeout: number): void;\n\n  /**\n   * Maximum time in milliseconds.\n   */\n  abstract getDefaultTimeout(): number;\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n\n  /**\n   * A shortcut for {@link Locator.race} that does not require static imports.\n   *\n   * @internal\n   */\n  locatorRace<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return Locator.race(locators);\n  }\n\n  /**\n   * Runs `document.querySelector` within the page. If no element matches the\n   * selector, the return value resolves to `null`.\n   *\n   * @param selector - A `selector` to query page for\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query page for.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().$(selector);\n  }\n\n  /**\n   * The method runs `document.querySelectorAll` within the page. If no elements\n   * match the selector, the return value resolves to `[]`.\n   *\n   * @param selector - A `selector` to query page for\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n   */\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return await this.mainFrame().$$(selector);\n  }\n\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Page.evaluate | page.evaluate} and\n   * `page.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * If the function passed to `page.evaluateHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle('document');\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle(() => document.body);\n   * const resultHandle = await page.evaluateHandle(\n   *   body => body.innerHTML,\n   *   aHandle\n   * );\n   * console.log(await resultHandle.jsonValue());\n   * await resultHandle.dispose();\n   * ```\n   *\n   * Most of the time this function returns a {@link JSHandle},\n   * but if `pageFunction` returns a reference to an element,\n   * you instead get an {@link ElementHandle} back:\n   *\n   * @example\n   *\n   * ```ts\n   * const button = await page.evaluateHandle(() =>\n   *   document.querySelector('button')\n   * );\n   * // can call `click` because `button` is an `ElementHandle`\n   * await button.click();\n   * ```\n   *\n   * The TypeScript definitions assume that `evaluateHandle` returns\n   * a `JSHandle`, but if you know it's going to return an\n   * `ElementHandle`, pass it as the generic argument:\n   *\n   * ```ts\n   * const button = await page.evaluateHandle<ElementHandle>(...);\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * This method iterates the JavaScript heap and finds all objects with the\n   * given prototype.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a Map object\n   * await page.evaluate(() => (window.map = new Map()));\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   *\n   * @param prototypeHandle - a handle to the object prototype.\n   * @returns Promise which resolves to a handle to an array of objects with\n   * this prototype.\n   */\n  abstract queryObjects<Prototype>(\n    prototypeHandle: JSHandle<Prototype>\n  ): Promise<JSHandle<Prototype[]>>;\n\n  /**\n   * This method runs `document.querySelector` within the page and passes the\n   * result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of `document.querySelector(selector)` as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    return await this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the page and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent);\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const allInputValues = await page.$$eval<string[]>(\n   *   'input',\n   *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of\n   * `Array.from(document.querySelectorAll(selector))` as its first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * If no URLs are specified, this method returns cookies for the current page\n   * URL. If URLs are specified, only cookies for those URLs are returned.\n   */\n  abstract cookies(...urls: string[]): Promise<Cookie[]>;\n\n  abstract deleteCookie(...cookies: DeleteCookiesRequest[]): Promise<void>;\n\n  /**\n   * @example\n   *\n   * ```ts\n   * await page.setCookie(cookieObject1, cookieObject2);\n   * ```\n   */\n  abstract setCookie(...cookies: CookieParam[]): Promise<void>;\n\n  /**\n   * Adds a `<script>` tag into the page with the desired URL or content.\n   *\n   * @remarks\n   * Shortcut for\n   * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    return await this.mainFrame().addScriptTag(options);\n  }\n\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired URL or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * Shortcut for\n   * {@link Frame.(addStyleTag:2) | page.mainFrame().addStyleTag(options)}.\n   *\n   * @returns An {@link ElementHandle | element handle} to the injected `<link>`\n   * or `<style>` element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    return await this.mainFrame().addStyleTag(options);\n  }\n\n  /**\n   * The method adds a function called `name` on the page's `window` object.\n   * When called, the function executes `puppeteerFunction` in node.js and\n   * returns a `Promise` which resolves to the return value of\n   * `puppeteerFunction`.\n   *\n   * If the puppeteerFunction returns a `Promise`, it will be awaited.\n   *\n   * :::note\n   *\n   * Functions installed via `page.exposeFunction` survive navigations.\n   *\n   * :::\n   *\n   * @example\n   * An example of adding an `md5` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import crypto from 'crypto';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('md5', text =>\n   *     crypto.createHash('md5').update(text).digest('hex')\n   *   );\n   *   await page.evaluate(async () => {\n   *     // use window.md5 to compute hashes\n   *     const myString = 'PUPPETEER';\n   *     const myHash = await window.md5(myString);\n   *     console.log(`md5 of ${myString} is ${myHash}`);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * An example of adding a `window.readfile` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import fs from 'fs';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('readfile', async filePath => {\n   *     return new Promise((resolve, reject) => {\n   *       fs.readFile(filePath, 'utf8', (err, text) => {\n   *         if (err) reject(err);\n   *         else resolve(text);\n   *       });\n   *     });\n   *   });\n   *   await page.evaluate(async () => {\n   *     // use window.readfile to read contents of a file\n   *     const content = await window.readfile('/etc/hosts');\n   *     console.log(content);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param name - Name of the function on the window object\n   * @param pptrFunction - Callback function which will be called in Puppeteer's\n   * context.\n   */\n  abstract exposeFunction(\n    name: string,\n    pptrFunction: Function | {default: Function}\n  ): Promise<void>;\n\n  /**\n   * The method removes a previously added function via ${@link Page.exposeFunction}\n   * called `name` from the page's `window` object.\n   */\n  abstract removeExposedFunction(name: string): Promise<void>;\n\n  /**\n   * Provide credentials for `HTTP authentication`.\n   *\n   * @remarks\n   * To disable authentication, pass `null`.\n   */\n  abstract authenticate(credentials: Credentials): Promise<void>;\n\n  /**\n   * The extra HTTP headers will be sent with every request the page initiates.\n   *\n   * :::tip\n   *\n   * All HTTP header names are lowercased. (HTTP headers are\n   * case-insensitive, so this shouldn’t impact your server code.)\n   *\n   * :::\n   *\n   * :::note\n   *\n   * page.setExtraHTTPHeaders does not guarantee the order of headers in\n   * the outgoing requests.\n   *\n   * :::\n   *\n   * @param headers - An object containing additional HTTP headers to be sent\n   * with every request. All header values must be strings.\n   */\n  abstract setExtraHTTPHeaders(headers: Record<string, string>): Promise<void>;\n\n  /**\n   * @param userAgent - Specific user agent to use in this page\n   * @param userAgentData - Specific user agent client hint data to use in this\n   * page\n   * @returns Promise which resolves when the user agent is set.\n   */\n  abstract setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void>;\n\n  /**\n   * Object containing metrics as key/value pairs.\n   *\n   * @returns\n   *\n   * - `Timestamp` : The timestamp when the metrics sample was taken.\n   *\n   * - `Documents` : Number of documents in the page.\n   *\n   * - `Frames` : Number of frames in the page.\n   *\n   * - `JSEventListeners` : Number of events in the page.\n   *\n   * - `Nodes` : Number of DOM nodes in the page.\n   *\n   * - `LayoutCount` : Total number of full or partial page layout.\n   *\n   * - `RecalcStyleCount` : Total number of page style recalculations.\n   *\n   * - `LayoutDuration` : Combined durations of all page layouts.\n   *\n   * - `RecalcStyleDuration` : Combined duration of all page style\n   *   recalculations.\n   *\n   * - `ScriptDuration` : Combined duration of JavaScript execution.\n   *\n   * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n   *\n   * - `JSHeapUsedSize` : Used JavaScript heap size.\n   *\n   * - `JSHeapTotalSize` : Total JavaScript heap size.\n   *\n   * @remarks\n   * All timestamps are in monotonic time: monotonically increasing time\n   * in seconds since an arbitrary point in the past.\n   */\n  abstract metrics(): Promise<Metrics>;\n\n  /**\n   * The page's URL.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.url | page.mainFrame().url()}.\n   */\n  url(): string {\n    return this.mainFrame().url();\n  }\n\n  /**\n   * The full HTML contents of the page, including the DOCTYPE.\n   */\n  async content(): Promise<string> {\n    return await this.mainFrame().content();\n  }\n\n  /**\n   * Set the content of the page.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Parameters that has some properties.\n   *\n   * @remarks\n   *\n   * The parameter `options` might have the following options.\n   *\n   * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n   *   to 30 seconds, pass `0` to disable timeout. The default value can be\n   *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider setting markup succeeded, defaults to\n   *   `load`. Given an array of event strings, setting content is considered\n   *   to be successful after all events have been fired. Events can be\n   *   either:<br/>\n   * - `load` : consider setting content to be finished when the `load` event\n   *   is fired.<br/>\n   * - `domcontentloaded` : consider setting content to be finished when the\n   *   `DOMContentLoaded` event is fired.<br/>\n   * - `networkidle0` : consider setting content to be finished when there are\n   *   no more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider setting content to be finished when there are\n   *   no more than 2 network connections for at least `500` ms.\n   */\n  async setContent(html: string, options?: WaitForOptions): Promise<void> {\n    await this.mainFrame().setContent(html, options);\n  }\n\n  /**\n   * Navigates the page to the given `url`.\n   *\n   * @remarks\n   *\n   * Navigation to `about:blank` or navigation to the same URL with a different\n   * hash will succeed and return `null`.\n   *\n   * :::warning\n   *\n   * Headless mode doesn't support navigation to a PDF document. See the {@link\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * :::\n   *\n   * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n   *\n   * @param url - URL to navigate page to. The URL should include scheme, e.g.\n   * `https://`\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @throws If:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   * - target URL is invalid.\n   * - the timeout is exceeded during navigation.\n   * - the remote server does not respond or is unreachable.\n   * - the main resource failed to load.\n   *\n   * This method will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\". The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   */\n  async goto(url: string, options?: GoToOptions): Promise<HTTPResponse | null> {\n    return await this.mainFrame().goto(url, options);\n  }\n\n  /**\n   * Reloads the page.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n  abstract reload(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Waits for the page to navigate to a new URL or to reload. It is useful when\n   * you run code that will indirectly cause the page to navigate.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(), // The promise resolves after navigation has finished\n   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n   * ]);\n   * ```\n   *\n   * @remarks\n   *\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns A `Promise` which resolves to the main resource response.\n   *\n   * - In case of multiple redirects, the navigation will resolve with the\n   *   response of the last redirect.\n   * - In case of navigation to a different anchor or navigation due to History\n   *   API usage, the navigation will resolve with `null`.\n   */\n  async waitForNavigation(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.mainFrame().waitForNavigation(options);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched request\n   * @example\n   *\n   * ```ts\n   * const firstRequest = await page.waitForRequest(\n   *   'https://example.com/resource'\n   * );\n   * const finalRequest = await page.waitForRequest(\n   *   request => request.url() === 'https://example.com'\n   * );\n   * return finalRequest.response()?.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Waiting Parameters have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n   *   `0` to disable the timeout. The default value can be changed by using the\n   *   {@link Page.setDefaultTimeout} method.\n   */\n  waitForRequest(\n    urlOrPredicate: string | AwaitablePredicate<HTTPRequest>,\n    options: WaitTimeoutOptions = {}\n  ): Promise<HTTPRequest> {\n    const {timeout: ms = this._timeoutSettings.timeout()} = options;\n    if (typeof urlOrPredicate === 'string') {\n      const url = urlOrPredicate;\n      urlOrPredicate = (request: HTTPRequest) => {\n        return request.url() === url;\n      };\n    }\n    const observable$ = fromEmitterEvent(this, PageEvent.Request).pipe(\n      filterAsync(urlOrPredicate),\n      raceWith(\n        timeout(ms),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n    return firstValueFrom(observable$);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched response.\n   * @example\n   *\n   * ```ts\n   * const firstResponse = await page.waitForResponse(\n   *   'https://example.com/resource'\n   * );\n   * const finalResponse = await page.waitForResponse(\n   *   response =>\n   *     response.url() === 'https://example.com' && response.status() === 200\n   * );\n   * const finalResponse = await page.waitForResponse(async response => {\n   *   return (await response.text()).includes('<html>');\n   * });\n   * return finalResponse.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Parameter have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n   *   pass `0` to disable the timeout. The default value can be changed by using\n   *   the {@link Page.setDefaultTimeout} method.\n   */\n  waitForResponse(\n    urlOrPredicate: string | AwaitablePredicate<HTTPResponse>,\n    options: WaitTimeoutOptions = {}\n  ): Promise<HTTPResponse> {\n    const {timeout: ms = this._timeoutSettings.timeout()} = options;\n    if (typeof urlOrPredicate === 'string') {\n      const url = urlOrPredicate;\n      urlOrPredicate = (response: HTTPResponse) => {\n        return response.url() === url;\n      };\n    }\n    const observable$ = fromEmitterEvent(this, PageEvent.Response).pipe(\n      filterAsync(urlOrPredicate),\n      raceWith(\n        timeout(ms),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n    return firstValueFrom(observable$);\n  }\n\n  /**\n   * Waits for the network to be idle.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves once the network is idle.\n   */\n  waitForNetworkIdle(options: WaitForNetworkIdleOptions = {}): Promise<void> {\n    return firstValueFrom(this.waitForNetworkIdle$(options));\n  }\n\n  /**\n   * @internal\n   */\n  waitForNetworkIdle$(\n    options: WaitForNetworkIdleOptions = {}\n  ): Observable<void> {\n    const {\n      timeout: ms = this._timeoutSettings.timeout(),\n      idleTime = NETWORK_IDLE_TIME,\n      concurrency = 0,\n    } = options;\n\n    return this.#inflight$.pipe(\n      switchMap(inflight => {\n        if (inflight > concurrency) {\n          return EMPTY;\n        }\n        return timer(idleTime);\n      }),\n      map(() => {}),\n      raceWith(\n        timeout(ms),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n  }\n\n  /**\n   * Waits for a frame matching the given conditions to appear.\n   *\n   * @example\n   *\n   * ```ts\n   * const frame = await page.waitForFrame(async frame => {\n   *   return frame.name() === 'Test';\n   * });\n   * ```\n   */\n  async waitForFrame(\n    urlOrPredicate: string | ((frame: Frame) => Awaitable<boolean>),\n    options: WaitTimeoutOptions = {}\n  ): Promise<Frame> {\n    const {timeout: ms = this.getDefaultTimeout()} = options;\n\n    if (isString(urlOrPredicate)) {\n      urlOrPredicate = (frame: Frame) => {\n        return urlOrPredicate === frame.url();\n      };\n    }\n\n    return await firstValueFrom(\n      merge(\n        fromEmitterEvent(this, PageEvent.FrameAttached),\n        fromEmitterEvent(this, PageEvent.FrameNavigated),\n        from(this.frames())\n      ).pipe(\n        filterAsync(urlOrPredicate),\n        first(),\n        raceWith(\n          timeout(ms),\n          fromEmitterEvent(this, PageEvent.Close).pipe(\n            map(() => {\n              throw new TargetCloseError('Page closed.');\n            })\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * This method navigate to the previous page in history.\n   * @param options - Navigation parameters\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go back, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil` : When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  abstract goBack(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * This method navigate to the next page in history.\n   * @param options - Navigation Parameter\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go forward, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  abstract goForward(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Brings page to front (activates tab).\n   */\n  abstract bringToFront(): Promise<void>;\n\n  /**\n   * Emulates a given device's metrics and user agent.\n   *\n   * To aid emulation, Puppeteer provides a list of known devices that can be\n   * via {@link KnownDevices}.\n   *\n   * @remarks\n   * This method is a shortcut for calling two methods:\n   * {@link Page.setUserAgent} and {@link Page.setViewport}.\n   *\n   * This method will resize the page. A lot of websites don't expect phones to\n   * change size, so you should emulate before navigating to the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import {KnownDevices} from 'puppeteer';\n   * const iPhone = KnownDevices['iPhone 6'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulate(iPhone);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   */\n  async emulate(device: Device): Promise<void> {\n    await Promise.all([\n      this.setUserAgent(device.userAgent),\n      this.setViewport(device.viewport),\n    ]);\n  }\n\n  /**\n   * @param enabled - Whether or not to enable JavaScript on the page.\n   * @remarks\n   * NOTE: changing this value won't affect scripts that have already been run.\n   * It will take full effect on the next navigation.\n   */\n  abstract setJavaScriptEnabled(enabled: boolean): Promise<void>;\n\n  /**\n   * Toggles bypassing page's Content-Security-Policy.\n   * @param enabled - sets bypassing of page's Content-Security-Policy.\n   * @remarks\n   * NOTE: CSP bypassing happens at the moment of CSP initialization rather than\n   * evaluation. Usually, this means that `page.setBypassCSP` should be called\n   * before navigating to the domain.\n   */\n  abstract setBypassCSP(enabled: boolean): Promise<void>;\n\n  /**\n   * @param type - Changes the CSS media type of the page. The only allowed\n   * values are `screen`, `print` and `null`. Passing `null` disables CSS media\n   * emulation.\n   * @example\n   *\n   * ```ts\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → false\n   *\n   * await page.emulateMediaType('print');\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → false\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → true\n   *\n   * await page.emulateMediaType(null);\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → false\n   * ```\n   */\n  abstract emulateMediaType(type?: string): Promise<void>;\n\n  /**\n   * Enables CPU throttling to emulate slow CPUs.\n   * @param factor - slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).\n   */\n  abstract emulateCPUThrottling(factor: number | null): Promise<void>;\n\n  /**\n   * @param features - `<?Array<Object>>` Given an array of media feature\n   * objects, emulates CSS media features on the page. Each media feature object\n   * must have the following properties:\n   * @example\n   *\n   * ```ts\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // → false\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([{name: 'color-gamut', value: 'p3'}]);\n   * await page.evaluate(() => matchMedia('(color-gamut: srgb)').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('(color-gamut: p3)').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('(color-gamut: rec2020)').matches);\n   * // → false\n   * ```\n   */\n  abstract emulateMediaFeatures(features?: MediaFeature[]): Promise<void>;\n\n  /**\n   * @param timezoneId - Changes the timezone of the page. See\n   * {@link https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt | ICU’s metaZones.txt}\n   * for a list of supported timezone IDs. Passing\n   * `null` disables timezone emulation.\n   */\n  abstract emulateTimezone(timezoneId?: string): Promise<void>;\n\n  /**\n   * Emulates the idle state.\n   * If no arguments set, clears idle state emulation.\n   *\n   * @example\n   *\n   * ```ts\n   * // set idle emulation\n   * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n   *\n   * // do some checks here\n   * ...\n   *\n   * // clear idle emulation\n   * await page.emulateIdleState();\n   * ```\n   *\n   * @param overrides - Mock idle state. If not set, clears idle overrides\n   */\n  abstract emulateIdleState(overrides?: {\n    isUserActive: boolean;\n    isScreenUnlocked: boolean;\n  }): Promise<void>;\n\n  /**\n   * Simulates the given vision deficiency on the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.goto('https://v8.dev/blog/10-years');\n   *\n   *   await page.emulateVisionDeficiency('achromatopsia');\n   *   await page.screenshot({path: 'achromatopsia.png'});\n   *\n   *   await page.emulateVisionDeficiency('deuteranopia');\n   *   await page.screenshot({path: 'deuteranopia.png'});\n   *\n   *   await page.emulateVisionDeficiency('blurredVision');\n   *   await page.screenshot({path: 'blurred-vision.png'});\n   *\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param type - the type of deficiency to simulate, or `'none'` to reset.\n   */\n  abstract emulateVisionDeficiency(\n    type?: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest['type']\n  ): Promise<void>;\n\n  /**\n   * `page.setViewport` will resize the page. A lot of websites don't expect\n   * phones to change size, so you should set the viewport before navigating to\n   * the page.\n   *\n   * In the case of multiple pages in a single browser, each page can have its\n   * own viewport size.\n   * @example\n   *\n   * ```ts\n   * const page = await browser.newPage();\n   * await page.setViewport({\n   *   width: 640,\n   *   height: 480,\n   *   deviceScaleFactor: 1,\n   * });\n   * await page.goto('https://example.com');\n   * ```\n   *\n   * @param viewport -\n   * @remarks\n   * NOTE: in certain cases, setting viewport will reload the page in order to\n   * set the isMobile or hasTouch properties.\n   */\n  abstract setViewport(viewport: Viewport): Promise<void>;\n\n  /**\n   * Returns the current page viewport settings without checking the actual page\n   * viewport.\n   *\n   * This is either the viewport set with the previous {@link Page.setViewport}\n   * call or the default viewport set via\n   * {@link BrowserConnectOptions.defaultViewport |\n   * BrowserConnectOptions.defaultViewport}.\n   */\n  abstract viewport(): Viewport | null;\n\n  /**\n   * Evaluates a function in the page's context and returns the result.\n   *\n   * If the function passed to `page.evaluate` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const result = await frame.evaluate(() => {\n   *   return Promise.resolve(8 * 7);\n   * });\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluate('1 + 2');\n   * ```\n   *\n   * To get the best TypeScript experience, you should pass in as the\n   * generic the type of `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluate(() => 2);\n   * ```\n   *\n   * @example\n   *\n   * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n   * as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const bodyHandle = await page.$('body');\n   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n   * await bodyHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   *\n   * @returns the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Adds a function which would be invoked in one of the following scenarios:\n   *\n   * - whenever the page is navigated\n   *\n   * - whenever the child frame is attached or navigated. In this case, the\n   *   function is invoked in the context of the newly attached frame.\n   *\n   * The function is invoked after the document was created but before any of\n   * its scripts were run. This is useful to amend the JavaScript environment,\n   * e.g. to seed `Math.random`.\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param args - Arguments to pass to `pageFunction`\n   * @example\n   * An example of overriding the navigator.languages property before the page loads:\n   *\n   * ```ts\n   * // preload.js\n   *\n   * // overwrite the `languages` property to use a custom getter\n   * Object.defineProperty(navigator, 'languages', {\n   *   get: function () {\n   *     return ['en-US', 'en', 'bn'];\n   *   },\n   * });\n   *\n   * // In your puppeteer script, assuming the preload.js file is\n   * // in same folder of our script.\n   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');\n   * await page.evaluateOnNewDocument(preloadFile);\n   * ```\n   */\n  abstract evaluateOnNewDocument<\n    Params extends unknown[],\n    Func extends (...args: Params) => unknown = (...args: Params) => unknown,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<NewDocumentScriptEvaluation>;\n\n  /**\n   * Removes script that injected into page by Page.evaluateOnNewDocument.\n   *\n   * @param identifier - script identifier\n   */\n  abstract removeScriptToEvaluateOnNewDocument(\n    identifier: string\n  ): Promise<void>;\n\n  /**\n   * Toggles ignoring cache for each request based on the enabled state. By\n   * default, caching is enabled.\n   * @param enabled - sets the `enabled` state of cache\n   * @defaultValue `true`\n   */\n  abstract setCacheEnabled(enabled?: boolean): Promise<void>;\n\n  /**\n   * @internal\n   */\n  async _maybeWriteBufferToFile(\n    path: string | undefined,\n    buffer: Buffer\n  ): Promise<void> {\n    if (!path) {\n      return;\n    }\n\n    const fs = await importFSPromises();\n\n    await fs.writeFile(path, buffer);\n  }\n\n  /**\n   * Captures a screencast of this {@link Page | page}.\n   *\n   * @example\n   * Recording a {@link Page | page}:\n   *\n   * ```\n   * import puppeteer from 'puppeteer';\n   *\n   * // Launch a browser\n   * const browser = await puppeteer.launch();\n   *\n   * // Create a new page\n   * const page = await browser.newPage();\n   *\n   * // Go to your site.\n   * await page.goto(\"https://www.example.com\");\n   *\n   * // Start recording.\n   * const recorder = await page.screencast({path: 'recording.webm'});\n   *\n   * // Do something.\n   *\n   * // Stop recording.\n   * await recorder.stop();\n   *\n   * browser.close();\n   * ```\n   *\n   * @param options - Configures screencast behavior.\n   *\n   * @experimental\n   *\n   * @remarks\n   *\n   * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n   * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n   *\n   * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n   */\n  async screencast(\n    options: Readonly<ScreencastOptions> = {}\n  ): Promise<ScreenRecorder> {\n    const [{ScreenRecorder}, [width, height, devicePixelRatio]] =\n      await Promise.all([\n        import('../node/ScreenRecorder.js'),\n        this.#getNativePixelDimensions(),\n      ]);\n\n    let crop: BoundingBox | undefined;\n    if (options.crop) {\n      const {\n        x,\n        y,\n        width: cropWidth,\n        height: cropHeight,\n      } = roundRectangle(normalizeRectangle(options.crop));\n      if (x < 0 || y < 0) {\n        throw new Error(\n          `\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`\n        );\n      }\n      if (cropWidth <= 0 || cropHeight <= 0) {\n        throw new Error(\n          `\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`\n        );\n      }\n\n      const viewportWidth = width / devicePixelRatio;\n      const viewportHeight = height / devicePixelRatio;\n      if (x + cropWidth > viewportWidth) {\n        throw new Error(\n          `\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`\n        );\n      }\n      if (y + cropHeight > viewportHeight) {\n        throw new Error(\n          `\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`\n        );\n      }\n\n      crop = {\n        x: x * devicePixelRatio,\n        y: y * devicePixelRatio,\n        width: cropWidth * devicePixelRatio,\n        height: cropHeight * devicePixelRatio,\n      };\n    }\n    if (options.speed !== undefined && options.speed <= 0) {\n      throw new Error(`\\`speed\\` must be greater than 0.`);\n    }\n    if (options.scale !== undefined && options.scale <= 0) {\n      throw new Error(`\\`scale\\` must be greater than 0.`);\n    }\n\n    const recorder = new ScreenRecorder(this, width, height, {\n      ...options,\n      path: options.ffmpegPath,\n      crop,\n    });\n    try {\n      await this._startScreencast();\n    } catch (error) {\n      void recorder.stop();\n      throw error;\n    }\n    if (options.path) {\n      const {createWriteStream} = await import('fs');\n      const stream = createWriteStream(options.path, 'binary');\n      recorder.pipe(stream);\n    }\n    return recorder;\n  }\n\n  #screencastSessionCount = 0;\n  #startScreencastPromise: Promise<void> | undefined;\n\n  /**\n   * @internal\n   */\n  async _startScreencast(): Promise<void> {\n    ++this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      this.#startScreencastPromise = this.mainFrame()\n        .client.send('Page.startScreencast', {format: 'png'})\n        .then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n    }\n    await this.#startScreencastPromise;\n  }\n\n  /**\n   * @internal\n   */\n  async _stopScreencast(): Promise<void> {\n    --this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      return;\n    }\n    this.#startScreencastPromise = undefined;\n    if (this.#screencastSessionCount === 0) {\n      await this.mainFrame().client.send('Page.stopScreencast');\n    }\n  }\n\n  /**\n   * Gets the native, non-emulated dimensions of the viewport.\n   */\n  async #getNativePixelDimensions(): Promise<\n    readonly [width: number, height: number, devicePixelRatio: number]\n  > {\n    const viewport = this.viewport();\n    using stack = new DisposableStack();\n    if (viewport && viewport.deviceScaleFactor !== 0) {\n      await this.setViewport({...viewport, deviceScaleFactor: 0});\n      stack.defer(() => {\n        void this.setViewport(viewport).catch(debugError);\n      });\n    }\n    return await this.mainFrame()\n      .isolatedRealm()\n      .evaluate(() => {\n        return [\n          window.visualViewport!.width * window.devicePixelRatio,\n          window.visualViewport!.height * window.devicePixelRatio,\n          window.devicePixelRatio,\n        ] as const;\n      });\n  }\n\n  /**\n   * Captures a screenshot of this {@link Page | page}.\n   *\n   * @param options - Configures screenshot behavior.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Buffer>;\n  @guarded(function () {\n    return this.browser();\n  })\n  async screenshot(\n    userOptions: Readonly<ScreenshotOptions> = {}\n  ): Promise<Buffer | string> {\n    await this.bringToFront();\n\n    // TODO: use structuredClone after Node 16 support is dropped.\n    const options = {\n      ...userOptions,\n      clip: userOptions.clip\n        ? {\n            ...userOptions.clip,\n          }\n        : undefined,\n    };\n    if (options.type === undefined && options.path !== undefined) {\n      const filePath = options.path;\n      // Note we cannot use Node.js here due to browser compatibility.\n      const extension = filePath\n        .slice(filePath.lastIndexOf('.') + 1)\n        .toLowerCase();\n      switch (extension) {\n        case 'png':\n          options.type = 'png';\n          break;\n        case 'jpeg':\n        case 'jpg':\n          options.type = 'jpeg';\n          break;\n        case 'webp':\n          options.type = 'webp';\n          break;\n      }\n    }\n    if (options.quality !== undefined) {\n      if (options.quality < 0 && options.quality > 100) {\n        throw new Error(\n          `Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`\n        );\n      }\n      if (\n        options.type === undefined ||\n        !['jpeg', 'webp'].includes(options.type)\n      ) {\n        throw new Error(\n          `${options.type ?? 'png'} screenshots do not support 'quality'.`\n        );\n      }\n    }\n    if (options.clip) {\n      if (options.clip.width <= 0) {\n        throw new Error(\"'width' in 'clip' must be positive.\");\n      }\n      if (options.clip.height <= 0) {\n        throw new Error(\"'height' in 'clip' must be positive.\");\n      }\n    }\n\n    setDefaultScreenshotOptions(options);\n\n    await using stack = new AsyncDisposableStack();\n    if (options.clip) {\n      if (options.fullPage) {\n        throw new Error(\"'clip' and 'fullPage' are mutually exclusive\");\n      }\n\n      options.clip = roundRectangle(normalizeRectangle(options.clip));\n    } else {\n      if (options.fullPage) {\n        // If `captureBeyondViewport` is `false`, then we set the viewport to\n        // capture the full page. Note this may be affected by on-page CSS and\n        // JavaScript.\n        if (!options.captureBeyondViewport) {\n          const scrollDimensions = await this.mainFrame()\n            .isolatedRealm()\n            .evaluate(() => {\n              const element = document.documentElement;\n              return {\n                width: element.scrollWidth,\n                height: element.scrollHeight,\n              };\n            });\n          const viewport = this.viewport();\n          await this.setViewport({\n            ...viewport,\n            ...scrollDimensions,\n          });\n          stack.defer(async () => {\n            if (viewport) {\n              await this.setViewport(viewport).catch(debugError);\n            } else {\n              await this.setViewport({\n                width: 0,\n                height: 0,\n              }).catch(debugError);\n            }\n          });\n        }\n      } else {\n        options.captureBeyondViewport = false;\n      }\n    }\n\n    const data = await this._screenshot(options);\n    if (options.encoding === 'base64') {\n      return data;\n    }\n    const buffer = Buffer.from(data, 'base64');\n    await this._maybeWriteBufferToFile(options.path, buffer);\n    return buffer;\n  }\n\n  /**\n   * @internal\n   */\n  abstract _screenshot(options: Readonly<ScreenshotOptions>): Promise<string>;\n\n  /**\n   * Generates a PDF of the page with the `print` CSS media type.\n   *\n   * @param options - options for generating the PDF.\n   *\n   * @remarks\n   *\n   * To generate a PDF with the `screen` media type, call\n   * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n   * calling `page.pdf()`.\n   *\n   * By default, `page.pdf()` generates a pdf with modified colors for printing.\n   * Use the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n   * property to force rendering of exact colors.\n   */\n  abstract createPDFStream(\n    options?: PDFOptions\n  ): Promise<ReadableStream<Uint8Array>>;\n\n  /**\n   * {@inheritDoc Page.createPDFStream}\n   */\n  abstract pdf(options?: PDFOptions): Promise<Buffer>;\n\n  /**\n   * The page's title\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n   */\n  async title(): Promise<string> {\n    return await this.mainFrame().title();\n  }\n\n  abstract close(options?: {runBeforeUnload?: boolean}): Promise<void>;\n\n  /**\n   * Indicates that the page has been closed.\n   * @returns\n   */\n  abstract isClosed(): boolean;\n\n  /**\n   * {@inheritDoc Mouse}\n   */\n  abstract get mouse(): Mouse;\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse} to click in the center of the\n   * element. If there's no element matching `selector`, the method throws an\n   * error.\n   *\n   * @remarks\n   *\n   * Bear in mind that if `click()` triggers a navigation event and\n   * there's a separate `page.waitForNavigation()` promise to be resolved, you\n   * may end up with a race condition that yields unexpected results. The\n   * correct pattern for click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   page.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n   * @param selector - A `selector` to search for element to click. If there are\n   * multiple elements satisfying the `selector`, the first will be clicked\n   * @param options - `Object`\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully clicked. The Promise will be rejected if there is no element\n   * matching `selector`.\n   */\n  click(selector: string, options?: Readonly<ClickOptions>): Promise<void> {\n    return this.mainFrame().click(selector, options);\n  }\n\n  /**\n   * This method fetches an element with `selector` and focuses it. If there's no\n   * element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n   * of an element to focus. If there are multiple elements satisfying the\n   * selector, the first will be focused.\n   * @returns Promise which resolves when the element matching selector is\n   * successfully focused. The promise will be rejected if there is no element\n   * matching selector.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n   */\n  focus(selector: string): Promise<void> {\n    return this.mainFrame().focus(selector);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse}\n   * to hover over the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to search for element to hover. If there are multiple elements satisfying\n   * the selector, the first will be hovered.\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully hovered. Promise gets rejected if there's no element matching\n   * `selector`.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n   */\n  hover(selector: string): Promise<void> {\n    return this.mainFrame().hover(selector);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * page.select('select#colors', 'blue'); // single selection\n   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to query the page for\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first one\n   * is taken into account.\n   * @returns\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.select | page.mainFrame().select()}\n   */\n  select(selector: string, ...values: string[]): Promise<string[]> {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.touchscreen}\n   * to tap in the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to search for element to tap. If there are multiple elements satisfying the\n   * selector, the first will be tapped.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n   */\n  tap(selector: string): Promise<void> {\n    return this.mainFrame().tap(selector);\n  }\n\n  /**\n   * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n   * in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n   * @example\n   *\n   * ```ts\n   * await page.type('#mytextarea', 'Hello');\n   * // Types instantly\n   * await page.type('#mytextarea', 'World', {delay: 100});\n   * // Types slower, like a user\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to type into. If there are multiple elements satisfying the\n   * selector, the first will be used.\n   * @param text - A text to type into a focused element.\n   * @param options - have property `delay` which is the Time to wait between\n   * key presses in milliseconds. Defaults to `0`.\n   * @returns\n   */\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    return this.mainFrame().type(selector, text, options);\n  }\n\n  /**\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately. If\n   * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigations:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by selector string\n   * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n   * selector is not found in DOM.\n   *\n   * @remarks\n   * The optional Parameter in Arguments `options` are:\n   *\n   * - `visible`: A boolean wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n   *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n   *   `false`.\n   *\n   * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n   *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n   *   by using the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().waitForSelector(selector, options);\n  }\n\n  /**\n   * Waits for the provided function, `pageFunction`, to return a truthy value when\n   * evaluated in the page's context.\n   *\n   * @example\n   * {@link Page.waitForFunction} can be used to observe a viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n   *   await page.setViewport({width: 50, height: 50});\n   *   await watchDog;\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * Arguments can be passed from Node.js to `pageFunction`:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await page.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {},\n   *   selector\n   * );\n   * ```\n   *\n   * @example\n   * The provided `pageFunction` can be asynchronous:\n   *\n   * ```ts\n   * const username = 'github-username';\n   * await page.waitForFunction(\n   *   async username => {\n   *     const githubResponse = await fetch(\n   *       `https://api.github.com/users/${username}`\n   *     );\n   *     const githubUser = await githubResponse.json();\n   *     // show the avatar\n   *     const img = document.createElement('img');\n   *     img.src = githubUser.avatar_url;\n   *     // wait 3 seconds\n   *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n   *     img.remove();\n   *   },\n   *   {},\n   *   username\n   * );\n   * ```\n   *\n   * @param pageFunction - Function to be evaluated in browser context until it returns a\n   * truthy value.\n   * @param options - Options for configuring waiting behavior.\n   */\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options?: FrameWaitForFunctionOptions,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  abstract waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.close().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.close();\n  }\n}\n\n/**\n * @internal\n */\nexport const supportedMetrics = new Set<string>([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  return {\n    ...clip,\n    ...(clip.width < 0\n      ? {\n          x: clip.x + clip.width,\n          width: -clip.width,\n        }\n      : {\n          x: clip.x,\n          width: clip.width,\n        }),\n    ...(clip.height < 0\n      ? {\n          y: clip.y + clip.height,\n          height: -clip.height,\n        }\n      : {\n          y: clip.y,\n          height: clip.height,\n        }),\n  };\n}\n\nfunction roundRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {...clip, x, y, width, height};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}