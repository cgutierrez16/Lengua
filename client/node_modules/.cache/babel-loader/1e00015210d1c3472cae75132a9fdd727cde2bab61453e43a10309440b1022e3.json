{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Session = void 0;\nconst EventEmitter_js_1 = require(\"../../common/EventEmitter.js\");\nconst util_js_1 = require(\"../../common/util.js\");\nconst decorators_js_1 = require(\"../../util/decorators.js\");\nconst disposable_js_1 = require(\"../../util/disposable.js\");\nconst Browser_js_1 = require(\"./Browser.js\");\n// TODO: Once Chrome supports session.status properly, uncomment this block.\n// const MAX_RETRIES = 5;\n/**\n * @internal\n */\nlet Session = (() => {\n  let _classSuper = EventEmitter_js_1.EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _connection_decorators;\n  let _connection_initializers = [];\n  let _dispose_decorators;\n  let _send_decorators;\n  let _subscribe_decorators;\n  let _addIntercepts_decorators;\n  let _end_decorators;\n  return class Session extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, null, _connection_decorators, {\n        kind: \"accessor\",\n        name: \"connection\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"connection\" in obj,\n          get: obj => obj.connection,\n          set: (obj, value) => {\n            obj.connection = value;\n          }\n        },\n        metadata: _metadata\n      }, _connection_initializers, _instanceExtraInitializers);\n      __esDecorate(this, null, _dispose_decorators, {\n        kind: \"method\",\n        name: \"dispose\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dispose\" in obj,\n          get: obj => obj.dispose\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _send_decorators, {\n        kind: \"method\",\n        name: \"send\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"send\" in obj,\n          get: obj => obj.send\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _subscribe_decorators, {\n        kind: \"method\",\n        name: \"subscribe\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"subscribe\" in obj,\n          get: obj => obj.subscribe\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _addIntercepts_decorators, {\n        kind: \"method\",\n        name: \"addIntercepts\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"addIntercepts\" in obj,\n          get: obj => obj.addIntercepts\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _end_decorators, {\n        kind: \"method\",\n        name: \"end\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"end\" in obj,\n          get: obj => obj.end\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    static async from(connection, capabilities) {\n      // Wait until the session is ready.\n      //\n      // TODO: Once Chrome supports session.status properly, uncomment this block\n      // and remove `getBiDiConnection` in BrowserConnector.\n      // let status = {message: '', ready: false};\n      // for (let i = 0; i < MAX_RETRIES; ++i) {\n      //   status = (await connection.send('session.status', {})).result;\n      //   if (status.ready) {\n      //     break;\n      //   }\n      //   // Backoff a little bit each time.\n      //   await new Promise(resolve => {\n      //     return setTimeout(resolve, (1 << i) * 100);\n      //   });\n      // }\n      // if (!status.ready) {\n      //   throw new Error(status.message);\n      // }\n      let result;\n      try {\n        result = (await connection.send('session.new', {\n          capabilities\n        })).result;\n      } catch (err) {\n        // Chrome does not support session.new.\n        (0, util_js_1.debugError)(err);\n        result = {\n          sessionId: '',\n          capabilities: {\n            acceptInsecureCerts: false,\n            browserName: '',\n            browserVersion: '',\n            platformName: '',\n            setWindowRect: false,\n            webSocketUrl: '',\n            userAgent: ''\n          }\n        };\n      }\n      const session = new Session(connection, result);\n      await session.#initialize();\n      return session;\n    }\n    #reason = (__runInitializers(this, _instanceExtraInitializers), void 0);\n    #disposables = new disposable_js_1.DisposableStack();\n    #info;\n    browser;\n    #connection_accessor_storage = __runInitializers(this, _connection_initializers, void 0);\n    get connection() {\n      return this.#connection_accessor_storage;\n    }\n    set connection(value) {\n      this.#connection_accessor_storage = value;\n    }\n    constructor(connection, info) {\n      super();\n      this.#info = info;\n      this.connection = connection;\n    }\n    async #initialize() {\n      // SAFETY: We use `any` to allow assignment of the readonly property.\n      this.browser = await Browser_js_1.Browser.from(this);\n      const browserEmitter = this.#disposables.use(this.browser);\n      browserEmitter.once('closed', ({\n        reason\n      }) => {\n        this.dispose(reason);\n      });\n      // TODO: Currently, some implementations do not emit navigationStarted event\n      // for fragment navigations (as per spec) and some do. This could emits a\n      // synthetic navigationStarted to work around this inconsistency.\n      const seen = new WeakSet();\n      this.on('browsingContext.fragmentNavigated', info => {\n        if (seen.has(info)) {\n          return;\n        }\n        seen.add(info);\n        this.emit('browsingContext.navigationStarted', info);\n        this.emit('browsingContext.fragmentNavigated', info);\n      });\n    }\n    get capabilities() {\n      return this.#info.capabilities;\n    }\n    get disposed() {\n      return this.ended;\n    }\n    get ended() {\n      return this.#reason !== undefined;\n    }\n    get id() {\n      return this.#info.sessionId;\n    }\n    dispose(reason) {\n      this.#reason = reason;\n      this[disposable_js_1.disposeSymbol]();\n    }\n    /**\n     * Currently, there is a 1:1 relationship between the session and the\n     * session. In the future, we might support multiple sessions and in that\n     * case we always needs to make sure that the session for the right session\n     * object is used, so we implement this method here, although it's not defined\n     * in the spec.\n     */\n    async send(method, params) {\n      return await this.connection.send(method, params);\n    }\n    async subscribe(events, contexts) {\n      await this.send('session.subscribe', {\n        events,\n        contexts\n      });\n    }\n    async addIntercepts(events, contexts) {\n      await this.send('session.subscribe', {\n        events,\n        contexts\n      });\n    }\n    async end() {\n      try {\n        await this.send('session.end', {});\n      } finally {\n        this.dispose(`Session already ended.`);\n      }\n    }\n    [(_connection_decorators = [(0, decorators_js_1.bubble)()], _dispose_decorators = [decorators_js_1.inertIfDisposed], _send_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], _subscribe_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], _addIntercepts_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], _end_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], disposable_js_1.disposeSymbol)]() {\n      this.#reason ??= 'Session already destroyed, probably because the connection broke.';\n      this.emit('ended', {\n        reason: this.#reason\n      });\n      this.#disposables.dispose();\n      super[disposable_js_1.disposeSymbol]();\n    }\n  };\n})();\nexports.Session = Session;","map":{"version":3,"names":["EventEmitter_js_1","require","util_js_1","decorators_js_1","disposable_js_1","Browser_js_1","Session","EventEmitter","_classSuper","__esDecorate","_connection_decorators","kind","name","static","private","access","has","obj","get","connection","set","value","metadata","_metadata","_connection_initializers","_instanceExtraInitializers","_dispose_decorators","dispose","_send_decorators","send","_subscribe_decorators","subscribe","_addIntercepts_decorators","addIntercepts","_end_decorators","end","from","capabilities","result","err","debugError","sessionId","acceptInsecureCerts","browserName","browserVersion","platformName","setWindowRect","webSocketUrl","userAgent","session","initialize","reason","__runInitializers","disposables","DisposableStack","info","browser","connection_accessor_storage","constructor","#initialize","Browser","browserEmitter","use","once","seen","WeakSet","on","add","emit","disposed","ended","undefined","id","disposeSymbol","method","params","events","contexts","bubble","inertIfDisposed","throwIfDisposed","exports"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/node_modules/puppeteer-core/src/bidi/core/Session.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type * as Bidi from 'chromium-bidi/lib/cjs/protocol/protocol.js';\n\nimport {EventEmitter} from '../../common/EventEmitter.js';\nimport {debugError} from '../../common/util.js';\nimport {\n  bubble,\n  inertIfDisposed,\n  throwIfDisposed,\n} from '../../util/decorators.js';\nimport {DisposableStack, disposeSymbol} from '../../util/disposable.js';\n\nimport {Browser} from './Browser.js';\nimport type {BidiEvents, Commands, Connection} from './Connection.js';\n\n// TODO: Once Chrome supports session.status properly, uncomment this block.\n// const MAX_RETRIES = 5;\n\n/**\n * @internal\n */\nexport class Session\n  extends EventEmitter<BidiEvents & {ended: {reason: string}}>\n  implements Connection<BidiEvents & {ended: {reason: string}}>\n{\n  static async from(\n    connection: Connection,\n    capabilities: Bidi.Session.CapabilitiesRequest\n  ): Promise<Session> {\n    // Wait until the session is ready.\n    //\n    // TODO: Once Chrome supports session.status properly, uncomment this block\n    // and remove `getBiDiConnection` in BrowserConnector.\n\n    // let status = {message: '', ready: false};\n    // for (let i = 0; i < MAX_RETRIES; ++i) {\n    //   status = (await connection.send('session.status', {})).result;\n    //   if (status.ready) {\n    //     break;\n    //   }\n    //   // Backoff a little bit each time.\n    //   await new Promise(resolve => {\n    //     return setTimeout(resolve, (1 << i) * 100);\n    //   });\n    // }\n    // if (!status.ready) {\n    //   throw new Error(status.message);\n    // }\n\n    let result;\n    try {\n      result = (\n        await connection.send('session.new', {\n          capabilities,\n        })\n      ).result;\n    } catch (err) {\n      // Chrome does not support session.new.\n      debugError(err);\n      result = {\n        sessionId: '',\n        capabilities: {\n          acceptInsecureCerts: false,\n          browserName: '',\n          browserVersion: '',\n          platformName: '',\n          setWindowRect: false,\n          webSocketUrl: '',\n          userAgent: '',\n        },\n      } satisfies Bidi.Session.NewResult;\n    }\n\n    const session = new Session(connection, result);\n    await session.#initialize();\n    return session;\n  }\n\n  #reason: string | undefined;\n  readonly #disposables = new DisposableStack();\n  readonly #info: Bidi.Session.NewResult;\n  readonly browser!: Browser;\n  @bubble()\n  accessor connection: Connection;\n\n  private constructor(connection: Connection, info: Bidi.Session.NewResult) {\n    super();\n\n    this.#info = info;\n    this.connection = connection;\n  }\n\n  async #initialize(): Promise<void> {\n    // SAFETY: We use `any` to allow assignment of the readonly property.\n    (this as any).browser = await Browser.from(this);\n\n    const browserEmitter = this.#disposables.use(this.browser);\n    browserEmitter.once('closed', ({reason}) => {\n      this.dispose(reason);\n    });\n\n    // TODO: Currently, some implementations do not emit navigationStarted event\n    // for fragment navigations (as per spec) and some do. This could emits a\n    // synthetic navigationStarted to work around this inconsistency.\n    const seen = new WeakSet();\n    this.on('browsingContext.fragmentNavigated', info => {\n      if (seen.has(info)) {\n        return;\n      }\n      seen.add(info);\n      this.emit('browsingContext.navigationStarted', info);\n      this.emit('browsingContext.fragmentNavigated', info);\n    });\n  }\n\n  get capabilities(): Bidi.Session.NewResult['capabilities'] {\n    return this.#info.capabilities;\n  }\n  get disposed(): boolean {\n    return this.ended;\n  }\n  get ended(): boolean {\n    return this.#reason !== undefined;\n  }\n  get id(): string {\n    return this.#info.sessionId;\n  }\n\n  @inertIfDisposed\n  private dispose(reason?: string): void {\n    this.#reason = reason;\n    this[disposeSymbol]();\n  }\n\n  /**\n   * Currently, there is a 1:1 relationship between the session and the\n   * session. In the future, we might support multiple sessions and in that\n   * case we always needs to make sure that the session for the right session\n   * object is used, so we implement this method here, although it's not defined\n   * in the spec.\n   */\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async send<T extends keyof Commands>(\n    method: T,\n    params: Commands[T]['params']\n  ): Promise<{result: Commands[T]['returnType']}> {\n    return await this.connection.send(method, params);\n  }\n\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async subscribe(\n    events: [string, ...string[]],\n    contexts?: [string, ...string[]]\n  ): Promise<void> {\n    await this.send('session.subscribe', {\n      events,\n      contexts,\n    });\n  }\n\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async addIntercepts(\n    events: [string, ...string[]],\n    contexts?: [string, ...string[]]\n  ): Promise<void> {\n    await this.send('session.subscribe', {\n      events,\n      contexts,\n    });\n  }\n\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async end(): Promise<void> {\n    try {\n      await this.send('session.end', {});\n    } finally {\n      this.dispose(`Session already ended.`);\n    }\n  }\n\n  [disposeSymbol](): void {\n    this.#reason ??=\n      'Session already destroyed, probably because the connection broke.';\n    this.emit('ended', {reason: this.#reason});\n\n    this.#disposables.dispose();\n    super[disposeSymbol]();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}