{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrameManager = void 0;\nconst CDPSession_js_1 = require(\"../api/CDPSession.js\");\nconst Frame_js_1 = require(\"../api/Frame.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst assert_js_1 = require(\"../util/assert.js\");\nconst Deferred_js_1 = require(\"../util/Deferred.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\nconst ErrorLike_js_1 = require(\"../util/ErrorLike.js\");\nconst CDPSession_js_2 = require(\"./CDPSession.js\");\nconst Connection_js_1 = require(\"./Connection.js\");\nconst DeviceRequestPrompt_js_1 = require(\"./DeviceRequestPrompt.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\nconst Frame_js_2 = require(\"./Frame.js\");\nconst FrameManagerEvents_js_1 = require(\"./FrameManagerEvents.js\");\nconst FrameTree_js_1 = require(\"./FrameTree.js\");\nconst IsolatedWorlds_js_1 = require(\"./IsolatedWorlds.js\");\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nclass FrameManager extends EventEmitter_js_1.EventEmitter {\n  #page;\n  #networkManager;\n  #timeoutSettings;\n  #contextIdToContext = new Map();\n  #isolatedWorlds = new Set();\n  #client;\n  _frameTree = new FrameTree_js_1.FrameTree();\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set();\n  #deviceRequestPromptManagerMap = new WeakMap();\n  #frameTreeHandled;\n  get timeoutSettings() {\n    return this.#timeoutSettings;\n  }\n  get networkManager() {\n    return this.#networkManager;\n  }\n  get client() {\n    return this.#client;\n  }\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager_js_1.NetworkManager(ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(util_js_1.debugError);\n    });\n  }\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred_js_1.Deferred.create({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped'\n    });\n    mainFrame.once(Frame_js_1.FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch (err) {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client) {\n    this.#onExecutionContextsCleared(this.#client);\n    this.#client = client;\n    (0, assert_js_1.assert)(this.#client instanceof CDPSession_js_2.CdpCDPSession, 'CDPSession is not an instance of CDPSessionImpl.');\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client._target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client._target()._targetId);\n      frame.mainRealm().clearContext();\n      frame.isolatedRealm().clearContext();\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client, true);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(util_js_1.debugError);\n    });\n    await this.initialize(client);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(Frame_js_1.FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n  async registerSpeculativeSession(client) {\n    await this.#networkManager.addClient(client);\n  }\n  setupEventListeners(session) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on('Page.frameDetached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameDetached(event.frameId, event.reason);\n    });\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', async () => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n  async initialize(client) {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred_js_1.Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchroniously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([this.#networkManager.addClient(client), client.send('Page.enable'), client.send('Page.getFrameTree').then(({\n        frameTree\n      }) => {\n        this.#handleFrameTree(client, frameTree);\n        this.#frameTreeHandled?.resolve();\n      }), client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), client.send('Runtime.enable').then(() => {\n        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);\n      })]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if ((0, ErrorLike_js_1.isErrorLike)(error) && (0, Connection_js_1.isTargetClosedError)(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  executionContextById(contextId, session = this.#client) {\n    const context = this.getExecutionContextById(contextId, session);\n    (0, assert_js_1.assert)(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n  getExecutionContextById(contextId, session = this.#client) {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n  page() {\n    return this.#page;\n  }\n  mainFrame() {\n    const mainFrame = this._frameTree.getMainFrame();\n    (0, assert_js_1.assert)(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n  frames() {\n    return Array.from(this._frameTree.frames());\n  }\n  frame(frameId) {\n    return this._frameTree.getById(frameId) || null;\n  }\n  onAttachedToTarget(target) {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session());\n    }\n    this.setupEventListeners(target._session());\n    void this.initialize(target._session());\n  }\n  _deviceRequestPromptManager(client) {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPrompt_js_1.DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n  #onLifecycleEvent(event) {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(Frame_js_1.FrameEvent.LifecycleEvent, undefined);\n  }\n  #onFrameStartedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n  #onFrameStoppedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(Frame_js_1.FrameEvent.LifecycleEvent, undefined);\n  }\n  #handleFrameTree(session, frameTree) {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n    if (!frameTree.childFrames) {\n      return;\n    }\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n  #onFrameAttached(session, frameId, parentFrameId) {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n    frame = new Frame_js_2.CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameAttached, frame);\n  }\n  async #onFrameNavigated(framePayload, navigationType) {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n    let frame = this._frameTree.getById(frameId);\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new Frame_js_2.CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(Frame_js_1.FrameEvent.FrameNavigated, navigationType);\n  }\n  async #createIsolatedWorld(session, name) {\n    const key = `${session.id()}:${name}`;\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${util_js_1.PuppeteerURL.INTERNAL_URL}`,\n      worldName: name\n    });\n    await Promise.all(this.frames().filter(frame => {\n      return frame.client === session;\n    }).map(frame => {\n      // Frames might be removed before we send this, so we don't want to\n      // throw an error.\n      return session.send('Page.createIsolatedWorld', {\n        frameId: frame._id,\n        worldName: name,\n        grantUniveralAccess: true\n      }).catch(util_js_1.debugError);\n    }));\n    this.#isolatedWorlds.add(key);\n  }\n  #onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(Frame_js_1.FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(Frame_js_1.FrameEvent.FrameNavigated, 'Navigation');\n  }\n  #onFrameDetached(frameId, reason) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(Frame_js_1.FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n  #onExecutionContextCreated(contextPayload, session) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD];\n      } else if (contextPayload.name === util_js_1.UTILITY_WORLD_NAME && !frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext_js_1.ExecutionContext(frame?.client || this.#client, contextPayload, world);\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n  #onExecutionContextDestroyed(executionContextId, session) {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n  #onExecutionContextsCleared(session) {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n  #removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposable_js_1.disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameDetached, frame);\n    frame.emit(Frame_js_1.FrameEvent.FrameDetached, frame);\n  }\n}\nexports.FrameManager = FrameManager;","map":{"version":3,"names":["CDPSession_js_1","require","Frame_js_1","EventEmitter_js_1","util_js_1","assert_js_1","Deferred_js_1","disposable_js_1","ErrorLike_js_1","CDPSession_js_2","Connection_js_1","DeviceRequestPrompt_js_1","ExecutionContext_js_1","Frame_js_2","FrameManagerEvents_js_1","FrameTree_js_1","IsolatedWorlds_js_1","NetworkManager_js_1","TIME_FOR_WAITING_FOR_SWAP","FrameManager","EventEmitter","page","networkManager","timeoutSettings","contextIdToContext","Map","isolatedWorlds","Set","client","_frameTree","FrameTree","frameNavigatedReceived","deviceRequestPromptManagerMap","WeakMap","frameTreeHandled","constructor","ignoreHTTPSErrors","NetworkManager","setupEventListeners","once","CDPSessionEvent","Disconnected","onClientDisconnect","catch","debugError","#onClientDisconnect","mainFrame","getMainFrame","child","childFrames","removeFramesRecursively","swapped","Deferred","create","timeout","message","FrameEvent","FrameSwappedByActivation","resolve","valueOrThrow","err","swapFrameTree","onExecutionContextsCleared","assert","CdpCDPSession","frame","add","_target","_targetId","removeFrame","updateId","mainRealm","clearContext","isolatedRealm","addFrame","updateClient","initialize","addClient","emit","undefined","registerSpeculativeSession","session","on","event","onFrameAttached","frameId","parentFrameId","id","onFrameNavigated","type","onFrameNavigatedWithinDocument","url","onFrameDetached","reason","onFrameStartedLoading","onFrameStoppedLoading","onExecutionContextCreated","context","onExecutionContextDestroyed","executionContextId","onLifecycleEvent","Promise","all","send","then","frameTree","handleFrameTree","enabled","createIsolatedWorld","UTILITY_WORLD_NAME","error","isErrorLike","isTargetClosedError","executionContextById","contextId","getExecutionContextById","get","frames","Array","from","getById","onAttachedToTarget","target","_getTargetInfo","targetId","_session","_deviceRequestPromptManager","manager","DeviceRequestPromptManager","set","#onLifecycleEvent","_onLifecycleEvent","loaderId","name","FrameManagerEvent","LifecycleEvent","#onFrameStartedLoading","_onLoadingStarted","#onFrameStoppedLoading","_onLoadingStopped","#handleFrameTree","parentId","has","delete","#onFrameAttached","isOOPFrame","CdpFrame","FrameAttached","#onFrameNavigated","framePayload","navigationType","isMainFrame","_id","waitForFrame","_navigated","FrameNavigated","#createIsolatedWorld","key","source","PuppeteerURL","INTERNAL_URL","worldName","filter","map","grantUniveralAccess","#onFrameNavigatedWithinDocument","_navigatedWithinDocument","FrameNavigatedWithinDocument","#onFrameDetached","FrameSwapped","#onExecutionContextCreated","contextPayload","auxData","world","worlds","MAIN_WORLD","PUPPETEER_WORLD","hasContext","ExecutionContext","setContext","#onExecutionContextDestroyed","_world","#onExecutionContextsCleared","entries","_client","#removeFramesRecursively","disposeSymbol","FrameDetached","exports"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/node_modules/puppeteer-core/src/cdp/FrameManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {type CDPSession, CDPSessionEvent} from '../api/CDPSession.js';\nimport {FrameEvent} from '../api/Frame.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport {debugError, PuppeteerURL, UTILITY_WORLD_NAME} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {CdpCDPSession} from './CDPSession.js';\nimport {isTargetClosedError} from './Connection.js';\nimport {DeviceRequestPromptManager} from './DeviceRequestPrompt.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {CdpFrame} from './Frame.js';\nimport type {FrameManagerEvents} from './FrameManagerEvents.js';\nimport {FrameManagerEvent} from './FrameManagerEvents.js';\nimport {FrameTree} from './FrameTree.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {NetworkManager} from './NetworkManager.js';\nimport type {CdpPage} from './Page.js';\nimport type {CdpTarget} from './Target.js';\n\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter<FrameManagerEvents> {\n  #page: CdpPage;\n  #networkManager: NetworkManager;\n  #timeoutSettings: TimeoutSettings;\n  #contextIdToContext = new Map<string, ExecutionContext>();\n  #isolatedWorlds = new Set<string>();\n  #client: CDPSession;\n\n  _frameTree = new FrameTree<CdpFrame>();\n\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set<string>();\n\n  #deviceRequestPromptManagerMap = new WeakMap<\n    CDPSession,\n    DeviceRequestPromptManager\n  >();\n\n  #frameTreeHandled?: Deferred<void>;\n\n  get timeoutSettings(): TimeoutSettings {\n    return this.#timeoutSettings;\n  }\n\n  get networkManager(): NetworkManager {\n    return this.#networkManager;\n  }\n\n  get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    page: CdpPage,\n    ignoreHTTPSErrors: boolean,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create<void>({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped',\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch (err) {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client: CDPSession): Promise<void> {\n    this.#onExecutionContextsCleared(this.#client);\n\n    this.#client = client;\n    assert(\n      this.#client instanceof CdpCDPSession,\n      'CDPSession is not an instance of CDPSessionImpl.'\n    );\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client._target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client._target()._targetId);\n      frame.mainRealm().clearContext();\n      frame.isolatedRealm().clearContext();\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client, true);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n\n  async registerSpeculativeSession(client: CdpCDPSession): Promise<void> {\n    await this.#networkManager.addClient(client);\n  }\n\n  private setupEventListeners(session: CDPSession) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on(\n      'Page.frameDetached',\n      async (event: Protocol.Page.FrameDetachedEvent) => {\n        await this.#frameTreeHandled?.valueOrThrow();\n        this.#onFrameDetached(\n          event.frameId,\n          event.reason as Protocol.Page.FrameDetachedEventReason\n        );\n      }\n    );\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', async () => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n\n  async initialize(client: CDPSession): Promise<void> {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchroniously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([\n        this.#networkManager.addClient(client),\n        client.send('Page.enable'),\n        client.send('Page.getFrameTree').then(({frameTree}) => {\n          this.#handleFrameTree(client, frameTree);\n          this.#frameTreeHandled?.resolve();\n        }),\n        client.send('Page.setLifecycleEventsEnabled', {enabled: true}),\n        client.send('Runtime.enable').then(() => {\n          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n        }),\n      ]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  executionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext {\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  getExecutionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext | undefined {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n\n  page(): CdpPage {\n    return this.#page;\n  }\n\n  mainFrame(): CdpFrame {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n\n  frames(): CdpFrame[] {\n    return Array.from(this._frameTree.frames());\n  }\n\n  frame(frameId: string): CdpFrame | null {\n    return this._frameTree.getById(frameId) || null;\n  }\n\n  onAttachedToTarget(target: CdpTarget): void {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session()!);\n    }\n    this.setupEventListeners(target._session()!);\n    void this.initialize(target._session()!);\n  }\n\n  _deviceRequestPromptManager(client: CDPSession): DeviceRequestPromptManager {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n\n  #onLifecycleEvent(event: Protocol.Page.LifecycleEventEvent): void {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #onFrameStartedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n\n  #onFrameStoppedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #handleFrameTree(\n    session: CDPSession,\n    frameTree: Protocol.Page.FrameTree\n  ): void {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(\n        session,\n        frameTree.frame.id,\n        frameTree.frame.parentId\n      );\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n\n    if (!frameTree.childFrames) {\n      return;\n    }\n\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n\n  #onFrameAttached(\n    session: CDPSession,\n    frameId: string,\n    parentFrameId: string\n  ): void {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n\n  async #onFrameNavigated(\n    framePayload: Protocol.Page.Frame,\n    navigationType: Protocol.Page.NavigationType\n  ): Promise<void> {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n\n    let frame = this._frameTree.getById(frameId);\n\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n\n  async #createIsolatedWorld(session: CDPSession, name: string): Promise<void> {\n    const key = `${session.id()}:${name}`;\n\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name,\n    });\n\n    await Promise.all(\n      this.frames()\n        .filter(frame => {\n          return frame.client === session;\n        })\n        .map(frame => {\n          // Frames might be removed before we send this, so we don't want to\n          // throw an error.\n          return session\n            .send('Page.createIsolatedWorld', {\n              frameId: frame._id,\n              worldName: name,\n              grantUniveralAccess: true,\n            })\n            .catch(debugError);\n        })\n    );\n\n    this.#isolatedWorlds.add(key);\n  }\n\n  #onFrameNavigatedWithinDocument(frameId: string, url: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n\n  #onFrameDetached(\n    frameId: string,\n    reason: Protocol.Page.FrameDetachedEventReason\n  ): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n\n  #onExecutionContextCreated(\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    session: CDPSession\n  ): void {\n    const auxData = contextPayload.auxData as {frameId?: string} | undefined;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world: IsolatedWorld | undefined;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (\n        contextPayload.name === UTILITY_WORLD_NAME &&\n        !frame.worlds[PUPPETEER_WORLD].hasContext()\n      ) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(\n      frame?.client || this.#client,\n      contextPayload,\n      world\n    );\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n\n  #onExecutionContextDestroyed(\n    executionContextId: number,\n    session: CDPSession\n  ): void {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n\n  #onExecutionContextsCleared(session: CDPSession): void {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n\n  #removeFramesRecursively(frame: CdpFrame): void {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}