{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ARIAQueryHandler = void 0;\nconst QueryHandler_js_1 = require(\"../common/QueryHandler.js\");\nconst assert_js_1 = require(\"../util/assert.js\");\nconst AsyncIterableUtil_js_1 = require(\"../util/AsyncIterableUtil.js\");\nconst NON_ELEMENT_NODE_ROLES = new Set(['StaticText', 'InlineTextBox']);\nconst queryAXTree = async (client, element, accessibleName, role) => {\n  const {\n    nodes\n  } = await client.send('Accessibility.queryAXTree', {\n    objectId: element.id,\n    accessibleName,\n    role\n  });\n  return nodes.filter(node => {\n    if (node.ignored) {\n      return false;\n    }\n    if (!node.role) {\n      return false;\n    }\n    if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {\n      return false;\n    }\n    return true;\n  });\n};\nconst isKnownAttribute = attribute => {\n  return ['name', 'role'].includes(attribute);\n};\nconst normalizeValue = value => {\n  return value.replace(/ +/g, ' ').trim();\n};\n/**\n * The selectors consist of an accessible name to query for and optionally\n * further aria attributes on the form `[<attribute>=<value>]`.\n * Currently, we only support the `name` and `role` attribute.\n * The following examples showcase how the syntax works wrt. querying:\n *\n * - 'title[role=\"heading\"]' queries for elements with name 'title' and role 'heading'.\n * - '[role=\"image\"]' queries for elements with role 'image' and any name.\n * - 'label' queries for elements with name 'label' and any role.\n * - '[name=\"\"][role=\"button\"]' queries for elements with no name and role 'button'.\n */\nconst ATTRIBUTE_REGEXP = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*(?<quote>\"|')(?<value>\\\\.|.*?(?=\\k<quote>))\\k<quote>\\s*\\]/g;\nconst parseARIASelector = selector => {\n  const queryOptions = {};\n  const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {\n    attribute = attribute.trim();\n    (0, assert_js_1.assert)(isKnownAttribute(attribute), `Unknown aria attribute \"${attribute}\" in selector`);\n    queryOptions[attribute] = normalizeValue(value);\n    return '';\n  });\n  if (defaultName && !queryOptions.name) {\n    queryOptions.name = normalizeValue(defaultName);\n  }\n  return queryOptions;\n};\n/**\n * @internal\n */\nclass ARIAQueryHandler extends QueryHandler_js_1.QueryHandler {\n  static querySelector = async (node, selector, {\n    ariaQuerySelector\n  }) => {\n    return await ariaQuerySelector(node, selector);\n  };\n  static async *queryAll(element, selector) {\n    const {\n      name,\n      role\n    } = parseARIASelector(selector);\n    const results = await queryAXTree(element.realm.environment.client, element, name, role);\n    yield* AsyncIterableUtil_js_1.AsyncIterableUtil.map(results, node => {\n      return element.realm.adoptBackendNode(node.backendDOMNodeId);\n    });\n  }\n  static queryOne = async (element, selector) => {\n    return (await AsyncIterableUtil_js_1.AsyncIterableUtil.first(this.queryAll(element, selector))) ?? null;\n  };\n}\nexports.ARIAQueryHandler = ARIAQueryHandler;","map":{"version":3,"names":["QueryHandler_js_1","require","assert_js_1","AsyncIterableUtil_js_1","NON_ELEMENT_NODE_ROLES","Set","queryAXTree","client","element","accessibleName","role","nodes","send","objectId","id","filter","node","ignored","has","value","isKnownAttribute","attribute","includes","normalizeValue","replace","trim","ATTRIBUTE_REGEXP","parseARIASelector","selector","queryOptions","defaultName","_","__","assert","name","ARIAQueryHandler","QueryHandler","querySelector","ariaQuerySelector","queryAll","results","realm","environment","AsyncIterableUtil","map","adoptBackendNode","backendDOMNodeId","queryOne","first","exports"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/node_modules/puppeteer-core/src/cdp/AriaQueryHandler.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport {QueryHandler, type QuerySelector} from '../common/QueryHandler.js';\nimport type {AwaitableIterable} from '../common/types.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\n\nconst NON_ELEMENT_NODE_ROLES = new Set(['StaticText', 'InlineTextBox']);\n\nconst queryAXTree = async (\n  client: CDPSession,\n  element: ElementHandle<Node>,\n  accessibleName?: string,\n  role?: string\n): Promise<Protocol.Accessibility.AXNode[]> => {\n  const {nodes} = await client.send('Accessibility.queryAXTree', {\n    objectId: element.id,\n    accessibleName,\n    role,\n  });\n  return nodes.filter((node: Protocol.Accessibility.AXNode) => {\n    if (node.ignored) {\n      return false;\n    }\n    if (!node.role) {\n      return false;\n    }\n    if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {\n      return false;\n    }\n    return true;\n  });\n};\n\ninterface ARIASelector {\n  name?: string;\n  role?: string;\n}\n\nconst isKnownAttribute = (\n  attribute: string\n): attribute is keyof ARIASelector => {\n  return ['name', 'role'].includes(attribute);\n};\n\nconst normalizeValue = (value: string): string => {\n  return value.replace(/ +/g, ' ').trim();\n};\n\n/**\n * The selectors consist of an accessible name to query for and optionally\n * further aria attributes on the form `[<attribute>=<value>]`.\n * Currently, we only support the `name` and `role` attribute.\n * The following examples showcase how the syntax works wrt. querying:\n *\n * - 'title[role=\"heading\"]' queries for elements with name 'title' and role 'heading'.\n * - '[role=\"image\"]' queries for elements with role 'image' and any name.\n * - 'label' queries for elements with name 'label' and any role.\n * - '[name=\"\"][role=\"button\"]' queries for elements with no name and role 'button'.\n */\nconst ATTRIBUTE_REGEXP =\n  /\\[\\s*(?<attribute>\\w+)\\s*=\\s*(?<quote>\"|')(?<value>\\\\.|.*?(?=\\k<quote>))\\k<quote>\\s*\\]/g;\nconst parseARIASelector = (selector: string): ARIASelector => {\n  const queryOptions: ARIASelector = {};\n  const defaultName = selector.replace(\n    ATTRIBUTE_REGEXP,\n    (_, attribute, __, value) => {\n      attribute = attribute.trim();\n      assert(\n        isKnownAttribute(attribute),\n        `Unknown aria attribute \"${attribute}\" in selector`\n      );\n      queryOptions[attribute] = normalizeValue(value);\n      return '';\n    }\n  );\n  if (defaultName && !queryOptions.name) {\n    queryOptions.name = normalizeValue(defaultName);\n  }\n  return queryOptions;\n};\n\n/**\n * @internal\n */\nexport class ARIAQueryHandler extends QueryHandler {\n  static override querySelector: QuerySelector = async (\n    node,\n    selector,\n    {ariaQuerySelector}\n  ) => {\n    return await ariaQuerySelector(node, selector);\n  };\n\n  static override async *queryAll(\n    element: ElementHandle<Node>,\n    selector: string\n  ): AwaitableIterable<ElementHandle<Node>> {\n    const {name, role} = parseARIASelector(selector);\n    const results = await queryAXTree(\n      element.realm.environment.client,\n      element,\n      name,\n      role\n    );\n    yield* AsyncIterableUtil.map(results, node => {\n      return element.realm.adoptBackendNode(node.backendDOMNodeId) as Promise<\n        ElementHandle<Node>\n      >;\n    });\n  }\n\n  static override queryOne = async (\n    element: ElementHandle<Node>,\n    selector: string\n  ): Promise<ElementHandle<Node> | null> => {\n    return (\n      (await AsyncIterableUtil.first(this.queryAll(element, selector))) ?? null\n    );\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}