{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsolatedWorld = void 0;\nconst Realm_js_1 = require(\"../api/Realm.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst Deferred_js_1 = require(\"../util/Deferred.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\nconst Mutex_js_1 = require(\"../util/Mutex.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/**\n * @internal\n */\nclass IsolatedWorld extends Realm_js_1.Realm {\n  #context = Deferred_js_1.Deferred.create();\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set();\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map();\n  get _bindings() {\n    return this.#bindings;\n  }\n  #frameOrWorker;\n  constructor(frameOrWorker, timeoutSettings) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n    this.frameUpdated();\n  }\n  get environment() {\n    return this.#frameOrWorker;\n  }\n  frameUpdated() {\n    this.client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n  get client() {\n    return this.#frameOrWorker.client;\n  }\n  clearContext() {\n    // The message has to match the CDP message expected by the WaitTask class.\n    this.#context?.reject(new Error('Execution context was destroyed'));\n    this.#context = Deferred_js_1.Deferred.create();\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n  setContext(context) {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.taskManager.rerunAll();\n  }\n  hasContext() {\n    return this.#context.resolved();\n  }\n  #executionContext() {\n    if (this.disposed) {\n      throw new Error(`Execution context is not available in detached frame \"${this.environment.url()}\" (are you trying to evaluate?)`);\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n  async evaluateHandle(pageFunction, ...args) {\n    pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);\n    const context = await this.#executionContext();\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n  async evaluate(pageFunction, ...args) {\n    pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);\n    let context = this.#context.value();\n    if (!context || !(context instanceof ExecutionContext_js_1.ExecutionContext)) {\n      context = await this.#executionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex_js_1.Mutex();\n  async _addBindingToContext(context, name) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      if (this.#contextBindings.has(name)) {\n        return;\n      }\n      const _ = __addDisposableResource(env_1, await this.#mutex.acquire(), false);\n      try {\n        await context._client.send('Runtime.addBinding', context._contextName ? {\n          name,\n          executionContextName: context._contextName\n        } : {\n          name,\n          executionContextId: context._contextId\n        });\n        await context.evaluate(utils_js_1.addPageBinding, 'internal', name);\n        this.#contextBindings.add(name);\n      } catch (error) {\n        // We could have tried to evaluate in a context which was already\n        // destroyed. This happens, for example, if the page is navigated while\n        // we are trying to add the binding\n        if (error instanceof Error) {\n          // Destroyed context.\n          if (error.message.includes('Execution context was destroyed')) {\n            return;\n          }\n          // Missing context.\n          if (error.message.includes('Cannot find context with specified id')) {\n            return;\n          }\n        }\n        (0, util_js_1.debugError)(error);\n      }\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  #onBindingCalled = async event => {\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      (0, util_js_1.debugError)(err);\n    }\n  };\n  async adoptBackendNode(backendNodeId) {\n    const executionContext = await this.#executionContext();\n    const {\n      object\n    } = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId\n    });\n    return (0, ExecutionContext_js_1.createCdpHandle)(this, object);\n  }\n  async adoptHandle(handle) {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return await handle.evaluateHandle(value => {\n        return value;\n      });\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id\n    });\n    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);\n  }\n  async transferHandle(handle) {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId\n    });\n    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);\n    await handle.dispose();\n    return newHandle;\n  }\n  [disposable_js_1.disposeSymbol]() {\n    super[disposable_js_1.disposeSymbol]();\n    this.client.off('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n}\nexports.IsolatedWorld = IsolatedWorld;","map":{"version":3,"names":["Realm_js_1","require","util_js_1","Deferred_js_1","disposable_js_1","Mutex_js_1","ExecutionContext_js_1","utils_js_1","IsolatedWorld","Realm","context","Deferred","create","contextBindings","Set","bindings","Map","_bindings","frameOrWorker","constructor","timeoutSettings","frameUpdated","environment","client","on","onBindingCalled","clearContext","reject","Error","clearDocumentHandle","setContext","clear","resolve","taskManager","rerunAll","hasContext","resolved","executionContext","#executionContext","disposed","url","valueOrThrow","evaluateHandle","pageFunction","args","withSourcePuppeteerURLIfNone","name","evaluate","value","ExecutionContext","mutex","Mutex","_addBindingToContext","has","_","__addDisposableResource","env_1","acquire","_client","send","_contextName","executionContextName","executionContextId","_contextId","addPageBinding","add","error","message","includes","debugError","event","payload","JSON","parse","type","seq","isTrivial","binding","get","run","err","adoptBackendNode","backendNodeId","object","createCdpHandle","adoptHandle","handle","realm","nodeInfo","objectId","id","node","transferHandle","remoteObject","undefined","info","newHandle","dispose","disposeSymbol","off","exports"],"sources":["/Users/carlosgutierrez/Documents/React/spanish/node_modules/puppeteer-core/src/cdp/IsolatedWorld.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {Realm} from '../api/Realm.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {BindingPayload, EvaluateFunc, HandleFor} from '../common/types.js';\nimport {debugError, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {Mutex} from '../util/Mutex.js';\n\nimport type {Binding} from './Binding.js';\nimport {ExecutionContext, createCdpHandle} from './ExecutionContext.js';\nimport type {CdpFrame} from './Frame.js';\nimport type {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {addPageBinding} from './utils.js';\nimport type {CdpWebWorker} from './WebWorker.js';\n\n/**\n * @internal\n */\nexport interface PageBinding {\n  name: string;\n  pptrFunction: Function;\n}\n\n/**\n * @internal\n */\nexport interface IsolatedWorldChart {\n  [key: string]: IsolatedWorld;\n  [MAIN_WORLD]: IsolatedWorld;\n  [PUPPETEER_WORLD]: IsolatedWorld;\n}\n\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context = Deferred.create<ExecutionContext>();\n\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set<string>();\n\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map<string, Binding>();\n\n  get _bindings(): Map<string, Binding> {\n    return this.#bindings;\n  }\n\n  readonly #frameOrWorker: CdpFrame | CdpWebWorker;\n\n  constructor(\n    frameOrWorker: CdpFrame | CdpWebWorker,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n    this.frameUpdated();\n  }\n\n  get environment(): CdpFrame | CdpWebWorker {\n    return this.#frameOrWorker;\n  }\n\n  frameUpdated(): void {\n    this.client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n\n  get client(): CDPSession {\n    return this.#frameOrWorker.client;\n  }\n\n  clearContext(): void {\n    // The message has to match the CDP message expected by the WaitTask class.\n    this.#context?.reject(new Error('Execution context was destroyed'));\n    this.#context = Deferred.create();\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n\n  setContext(context: ExecutionContext): void {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.taskManager.rerunAll();\n  }\n\n  hasContext(): boolean {\n    return this.#context.resolved();\n  }\n\n  #executionContext(): Promise<ExecutionContext> {\n    if (this.disposed) {\n      throw new Error(\n        `Execution context is not available in detached frame \"${this.environment.url()}\" (are you trying to evaluate?)`\n      );\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    const context = await this.#executionContext();\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    let context = this.#context.value();\n    if (!context || !(context instanceof ExecutionContext)) {\n      context = await this.#executionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(\n    context: ExecutionContext,\n    name: string\n  ): Promise<void> {\n    if (this.#contextBindings.has(name)) {\n      return;\n    }\n\n    using _ = await this.#mutex.acquire();\n    try {\n      await context._client.send(\n        'Runtime.addBinding',\n        context._contextName\n          ? {\n              name,\n              executionContextName: context._contextName,\n            }\n          : {\n              name,\n              executionContextId: context._contextId,\n            }\n      );\n\n      await context.evaluate(addPageBinding, 'internal', name);\n\n      this.#contextBindings.add(name);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n\n      debugError(error);\n    }\n  }\n\n  #onBindingCalled = async (\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> => {\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n\n  override async adoptBackendNode(\n    backendNodeId?: Protocol.DOM.BackendNodeId\n  ): Promise<JSHandle<Node>> {\n    const executionContext = await this.#executionContext();\n    const {object} = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId,\n    });\n    return createCdpHandle(this, object) as JSHandle<Node>;\n  }\n\n  async adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return (await handle.evaluateHandle(value => {\n        return value;\n      })) as unknown as T;\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id,\n    });\n    return (await this.adoptBackendNode(nodeInfo.node.backendNodeId)) as T;\n  }\n\n  async transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId,\n    });\n    const newHandle = (await this.adoptBackendNode(\n      info.node.backendNodeId\n    )) as T;\n    await handle.dispose();\n    return newHandle;\n  }\n\n  [disposeSymbol](): void {\n    super[disposeSymbol]();\n    this.client.off('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}